<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Data::Rlist - A lightweight data language for Perl, C and C++</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#venue">Venue</a></li>
		<li><a href="#audience">Audience</a></li>
		<li><a href="#number_and_string">Number and String</a></li>
		<li><a href="#here_documents">Here Documents</a></li>
		<li><a href="#character_encoding">Character Encoding</a></li>
		<li><a href="#binary_data">Binary Data</a></li>
		<li><a href="#embedded_perl_code">Embedded Perl Code</a></li>
		<li><a href="#comments">Comments</a></li>
	</ul>

	<li><a href="#examples">EXAMPLES</a></li>
	<li><a href="#package_details">PACKAGE DETAILS</a></li>
	<ul>

		<li><a href="#compile_options">Compile Options</a></li>
		<ul>

			<li><a href="#predefined_options">Predefined Options</a></li>
		</ul>

		<li><a href="#debugging_data__finding_selfreferences_">Debugging Data (Finding Self-References)</a></li>
		<li><a href="#quoting_strings_that_look_like_numbers">Quoting strings that look like numbers</a></li>
		<li><a href="#speedup_compilation">Speed-up Compilation</a></li>
		<ul>

			<li><a href="#explicit_quoting">Explicit Quoting</a></li>
		</ul>

	</ul>

	<li><a href="#package_functions">PACKAGE FUNCTIONS</a></li>
	<ul>

		<li><a href="#construct_objects">Construct Objects</a></li>
		<ul>

			<li><a href="#new____get___and_set__"><em>new()</em>, <em>get()</em> and <em>set()</em></a></li>
		</ul>

		<li><a href="#interface">Interface</a></li>
		<ul>

			<li><a href="#read____read_csv___and_read_string__"><em>read()</em>, <em>read_csv()</em> and <em>read_string()</em></a></li>
			<li><a href="#write____write_csv___and_write_string__"><em>write()</em>, <em>write_csv()</em> and <em>write_string()</em></a></li>
			<li><a href="#make_string___and_keelhaul__"><em>make_string()</em> and <em>keelhaul()</em></a></li>
		</ul>

		<li><a href="#implementation">Implementation</a></li>
		<ul>

			<li><a href="#open_input___and_close_input__"><em>open_input()</em> and <em>close_input()</em></a></li>
			<li><a href="#lex___and_parse__"><em>lex()</em> and <em>parse()</em></a></li>
			<li><a href="#errors____broken___and_missing_input__"><em>errors()</em>, <em>broken()</em> and <em>missing_input()</em></a></li>
			<li><a href="#compile__"><em>compile()</em></a></li>
		</ul>

	</ul>

	<li><a href="#auxiliary_functions">AUXILIARY FUNCTIONS</a></li>
	<ul>

		<li><a href="#is_numeric____is_name___and_is_random_text__"><em>is_numeric()</em>, <em>is_name()</em> and <em>is_random_text()</em></a></li>
		<li><a href="#quote____escape___and_unhere__"><em>quote()</em>, <em>escape()</em> and <em>unhere()</em></a></li>
		<li><a href="#split_quoted__"><em>split_quoted()</em></a></li>
		<li><a href="#equal___and_round__"><em>equal()</em> and <em>round()</em></a></li>
		<li><a href="#deep_compare__"><em>deep_compare()</em></a></li>
		<li><a href="#fork_and_wait____synthesize_pathname__"><em>fork_and_wait()</em>, <em>synthesize_pathname()</em></a></li>
	</ul>

	<li><a href="#imported_functions">IMPORTED FUNCTIONS</a></li>
	<ul>

		<li><a href="#explicit_imports">Explicit Imports</a></li>
		<li><a href="#automatic_imports">Automatic Imports</a></li>
		<li><a href="#importing_when_rlist_pm_is_installed_locally">Importing when <em>Rlist.pm</em> is installed locally</a></li>
		<li><a href="#readcsv___and_readdata__"><em>ReadCSV()</em> and <em>ReadData()</em></a></li>
		<li><a href="#writecsv___and_writedata__"><em>WriteCSV()</em> and <em>WriteData()</em></a></li>
		<li><a href="#outlinedata____stringizedata___and_squeezedata__"><em>OutlineData()</em>, <em>StringizeData()</em> and <em>SqueezeData()</em></a></li>
		<li><a href="#keelhauldata___and_comparedata__"><em>KeelhaulData()</em> and <em>CompareData()</em></a></li>
	</ul>

	<li><a href="#history___notes">HISTORY / NOTES</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<ul>

		<li><a href="#data__dumper"><em>Data::Dumper</em></a></li>
	</ul>

	<li><a href="#dependencies">DEPENDENCIES</a></li>
	<li><a href="#bugs_and_deficiencies">BUGS AND DEFICIENCIES</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright_and_license">COPYRIGHT AND LICENSE</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>Data::Rlist - A lightweight data language for Perl, C and C++</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    use Data::Rlist;
        .
        .</pre>
<p>Data from text:</p>
<pre>
    $string_ref = Data::Rlist::write_string($data);</pre>
<pre>
    $string     = Data::Rlist::make_string($data);</pre>
<pre>
    $data       = Data::Rlist::read_string($string_ref);</pre>
<pre>
    $data       = Data::Rlist::read_string($string);</pre>
<p>Data from files:</p>
<pre>
            Data::Rlist::write($data, $filename);</pre>
<pre>
    $data = Data::Rlist::read($filename);</pre>
<p>Perform safe deep copies of data:</p>
<pre>
    $deep_copy  = Data::Rlist::keelhaul($data);</pre>
<p>The same can be achieved with the object-oriented interface:</p>
<pre>
    $object = new Data::Rlist(-data =&gt; $thing, -output =&gt; \$target_string)</pre>
<p><em>-data</em> defines the data to be compiled, and <em>-output</em> where to write the compilation. <em>-output</em>
either defines a string reference or the name of a file:</p>
<pre>
    $string_ref = $object-&gt;write;       # compile $thing, return \$target_string</pre>
<pre>
    $object-&gt;set(-output =&gt; &quot;$HOME/.foorc&quot;); # refine as filename</pre>
<pre>
    $object-&gt;write;                     # write &quot;~/.foorc&quot;</pre>
<p>Passing an argument to <em>write()</em> eventually overrides <em>-output</em>:</p>
<pre>
    $object-&gt;write(&quot;.barrc&quot;);           # write to some other file</pre>
<p><em><a href="#item_write_string">write_string()</a></em> and <em><a href="#item_make_string">make_string()</a></em> make up a string out of thin air, no matter how
<em>-output</em> is set:</p>
<pre>
    $string_ref = $object-&gt;write_string; # write to new string (ignores -output)</pre>
<pre>
    $string     = $object-&gt;make_string; # dto. but return string value</pre>
<pre>
    print $object-&gt;make_string;         # ...dump $thing to stdout</pre>
<p>However, all these functions apply <em>-data</em> as the Perl data to be compiled.  The attribute
<em>-input</em> defines what to parse: <em>read()</em> compiles the text defined by <em>-input</em> back to Perl
data:</p>
<pre>
    $object-&gt;set(-input =&gt; \$rlist_language_productions);</pre>
<pre>
    $data = $object-&gt;read;</pre>
<pre>
    $data = $object-&gt;read($other); # overrides -input attribute</pre>
<p>Analog to <em>-data</em> the <em>-input</em> attribute shall be either a string-reference, <em>undef</em> or the name
of a file:</p>
<pre>
    use Env qw/HOME/;</pre>
<pre>
    $object-&gt;set(-input =&gt; &quot;$HOME/.foorc&quot;);</pre>
<pre>
    $data = $object-&gt;read;      # open and parse &quot;~/.foorc&quot;</pre>
<pre>
    $data = $object-&gt;read(&quot;.barrc&quot;); # parse some other file (override -input)</pre>
<pre>
    $data = $object-&gt;read(\$string); # parse some string (override -input)</pre>
<pre>
    $data = $object-&gt;read_string($string_or_ref); # dto.</pre>
<p><strong>KEELHAULING DATA</strong></p>
<p><em>Data::Rlist</em> can also create deep-copies of Perl data, a functionality called <em>keelhauling</em>:</p>
<pre>
    $deep_copy = $object-&gt;keelhaul; # create in-depth copy of $thing</pre>
<p>The metaphor vividly connotes that <em>$thing</em> is stringified, then compiled back.  See
<em><a href="#item_keelhaul">keelhaul()</a></em> for why this only sounds useless.  The little brother of <em><a href="#item_keelhaul">keelhaul()</a></em> is
<em><a href="#item_deep_compare">deep_compare()</a></em>:</p>
<pre>
    print join(&quot;\n&quot;, Data::Rlist::deep_compare($a, $b));</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>
</p>
<h2><a name="venue">Venue</a></h2>
<p><em>Random-Lists</em> (Rlist) is a tag/value format for text data.  It converts objects into legible,
plain text.  Rlist is a data format language that uses lists of (a) values and (b) tags and values
to structure data. Shortly, to <em>stringify objects</em>.  The design targets the simplest (yet
complete) language for constant data:</p>
<p>- it allows the definition of hierachical data,</p>
<p>- it disallows recursively-defined data,</p>
<p>- it does not consider user-defined types,</p>
<p>- it has no keywords,</p>
<p>- it has no arithmetic expressions,</p>
<p>- it uses 7-bit-ASCII character encoding.</p>
<p>Rlists are not Perl syntax, and can be used also from C and C++ programs.</p>
<pre>
    RLIST    PERL
    -----    ----
     5;       { 5 =&gt; undef }
     &quot;5&quot;;     { &quot;5&quot; =&gt; undef }
     5=1;     { 5 =&gt; 1 }
     {5=1;}   { 5 =&gt; 1 }
     (5)      [ 5 ]
     {}       { }
     ;        { }
     ()       [ ]</pre>
<dl>
<dt><strong><a name="item_strings_and_numbers">Strings and Numbers</a></strong>

<dd>
<pre>
    &quot;Hello, World!&quot;</pre>
</dd>
<dd>
<p>Symbolic names are simply strings consisting only of <em>[a-zA-Z_0-9-/~:.@]</em> characters. For such
strings the quotes are optional:</p>
</dd>
<dd>
<pre>
    foobar   cogito.ergo.sum   Memento::mori</pre>
</dd>
<dd>
<p>Numbers adhere to the IEEE 754 syntax for integer- and floating-point numbers:</p>
</dd>
<dd>
<pre>
    38   10e-6   -.7   3.141592653589793</pre>
</dd>
<dt><strong><a name="item_array">Array</a></strong>

<dd>
<p>Arrays are sequential lists:</p>
</dd>
<dd>
<pre>
    ( 1, 2, ( 3, &quot;Audiatur et altera pars!&quot; ) )</pre>
</dd>
</li>
<dt><strong><a name="item_hash">Hash</a></strong>

<dd>
<p>Hashes map a key scalar to some value, a subsquent Rlist.  Hashes are associative lists:</p>
</dd>
<dd>
<pre>
    {
        key = value;
        3.14159 = Pi;
        &quot;Meta-syntactic names&quot; = (foo, bar, baz, &quot;lorem ipsum&quot;, Acme, ___);
        lonely-key;
    }</pre>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="audience">Audience</a></h2>
<p>Rlist is useful as a ``glue data language'' between different systems and programs, for configuration
files and for persistence layers (object storage).  It attempts to represent the data pure and
untinged, but without breaking its structure or legibility.  The format excels over comma-separated
values (CSV), but isn't as excessive as XML:</p>
<ul>
<li>
<p>Like CSV the format describes merely the data itself, but the data may be structured in multiple
levels, not just lines.</p>
</li>
<li>
<p>Like XML data can be as complex as required, but while XML is geared to markup data within some
continuous text (the document), Rlist defines the pure data structure.  However, for
non-programmers the syntax is still self-evident.</p>
</li>
</ul>
<p>Rlists are built from only four primitives: <em>number</em>, <em>string</em>, <em>array</em> and <em>hash</em>.  The
penalty with Rlist hence is that data schemes are tacit consents between the users of the data (the
programs).</p>
<p>Implementations yet exist for Perl, C and C++, Windows and UN*X. These implementations are stable,
portable and very fast, and they do not depend on other software.  The Perl implementation operates
directly on primitive types, where C++ uses STL types.  Either way data integrity is guaranteed:
floats won't loose their precision, Perl strings are loaded into <em>std::string</em>s, and Perl hashes
and arrays resurrect in as <em>std::map</em>s and <em>std::vector</em>s.</p>
<p>Moreover, a design goal of Rlist was to scale perfectly well: a single text files can express
hundreds of megabytes of data, while the data is readable in constant time and with constant memory
requirements.  This makes Rlist files applicable as ``mini-databases'' loaded into RAM at program
startup.  For example, <a href="http://www.sternenfall.de">http://www.sternenfall.de</a> uses Rlist instead of a MySQL database.</p>
<p>
</p>
<h2><a name="number_and_string">Number and String</a></h2>
<p>All program data is finally convertible into numbers and strings.  In Rlist number and string
constants follow the C language lexicography.  Strings that look like C identifier names must not
be quoted.</p>
<p>By definition all input is compiled into an array or hash; hashes are the default. For example, the
string <code>&quot;Hello, World!&quot;</code> is compiled into:</p>
<pre>
    { &quot;Hello, World!&quot; =&gt; undef }</pre>
<p>Likewise the parser of the C++ implementation by default returns a <em>std::map</em> with one pair. The
default scalar value is the empty string <code>&quot;&quot;</code>. In Perl, <em>undef</em>'d list elements are compiled into
<code>&quot;&quot;</code>.</p>
<p>Strings are quoted implicitly when building Rlists; when reading them back strings are unquoted.
Quoting means to <a href="#character_encoding">encode characters</a>, then wrap the string into <code>&quot;</code>.  You can
can also make use of this functionality by calling <em><a href="#item_quote">quote()</a></em> and <em><a href="#item_unquote">unquote()</a></em> as separate
functions.</p>
<p>
</p>
<h2><a name="here_documents">Here Documents</a></h2>
<p>Rlist is capable of a line-oriented form of quoting based on the UNIX shell <em>here-document</em> syntax
and RFC 111.  Multi-line quoted strings can be expressed with</p>
<pre>
    &lt;&lt;DELIMITER</pre>
<p>Following the sigil <em> &lt;&lt; </em> an identifier specifies how to terminate the string scalar.  The value
of the scalar will be all lines following the current line down to the line starting with the
delimiter.  There must be no space between the <em> &lt;&lt; </em> and the identifier.  For example,</p>
<pre>
    {
        var = {
            log = {
                messages = &lt;&lt;LOG;
    Nov 27 21:55:04 localhost kernel: TSC appears to be running slowly. Marking it as unstable
    Nov 27 22:34:27 localhost kernel: Uniform CD-ROM driver Revision: 3.20
    Nov 27 22:34:27 localhost kernel: Loading iSCSI transport class v2.0-724.&lt;6&gt;PNP: No PS/2 controller found. Probing ports directly.
    Nov 27 22:34:27 localhost kernel: wifi0: Atheros 5212: mem=0x26000000, irq=11
    LOG
            };
        };
    }</pre>
<p>
</p>
<h2><a name="character_encoding">Character Encoding</a></h2>
<p>Rlist text uses 7-bit-ASCII.  The 95 printable character codes 32 to 126 occupy one character.
Codes 0 to 31 and 127 to 255 require four characters each: the <em>\</em> escape character followed by
the octal code number. For example, the German Umlaut character <em>&uuml;</em> (252) is translated into
<em>\374</em>.  An exception are codes 93 (backslash), 34 (double-quote) and 39 (single-quote), which are
escaped as</p>
<pre>
    \\   \&quot;   \'</pre>
<p>
</p>
<h2><a name="binary_data">Binary Data</a></h2>
<p>Binary data can be represented as base64-encoded string or <a href="#here_documents">here-document</a>.</p>
<p>
</p>
<h2><a name="embedded_perl_code">Embedded Perl Code</a></h2>
<p>Rlists may define embedded programs: <em>nanonscripts</em>.  They're defined as <a href="#here_documents">here-document</a> that is delimited with the special string ``nanoscript''.  For example,</p>
<pre>
    hello = (&lt;&lt;nanoscript);
    print &quot;Hello, World!&quot;;
    nanoscript</pre>
<p>After the Rlist has been fully parsed such strings are <em>eval</em>'d in the order of their occurrence.
Within the <em>eval</em> <em>%root</em> or <em>@root</em> defines the root of the current Rlist.</p>
<p>
</p>
<h2><a name="comments">Comments</a></h2>
<p>Rlist supports multiple forms of comments: <em>//</em> or <em>#</em> single-line-comments, and <em>/* */</em>
multi-line-comments.</p>
<p>
</p>
<hr />
<h1><a name="examples">EXAMPLES</a></h1>
<p>Basic Rlist values are number and string constants, from which larger structures are built.  All of
the following paragraphs define valid Rlists.</p>
<p>Single strings and numbers:</p>
<pre>
    &quot;Hello, World!&quot;</pre>
<pre>
    foo                     // compiles to { 'foo' =&gt; undef }</pre>
<pre>
    3.1415                  // compiles to { 3.1415 =&gt; undef }</pre>
<p>Array:</p>
<pre>
    (1, a, 4, &quot;b u z&quot;)      // list of numbers/strings</pre>
<pre>
    ((1, 2),
     (3, 4))                // list of list (4x4 matrix)</pre>
<pre>
    ((1, a, 3, &quot;foo bar&quot;),
     (7, c, 0, &quot;&quot;))         // another list of lists</pre>
<p>Array of strings:</p>
<pre>
    warning = (
        &quot;main correlation-matrix not positive-definite&quot;, 
        &quot;using pseudo-decomposed sigma-matrix&quot;, 
        &quot;cannot evaluate CVaR: the no. of simulations is to low for confidence-level 0.90&quot;
    );</pre>
<p>Configuration object as hash:</p>
<pre>
    {
        contribution_quantile = 0.99;
        default_only_mode = Y;
        importance_sampling = N;
        num_runs = 10000;
        num_threads = 10;
        # etc.
    }</pre>
<p>A comprehensive example:</p>
<pre>
    &quot;Metaphysic-terms&quot; =
    {
        Numbers =
        {
            3.141592653589793 = &quot;The ratio of a circle's circumference to its diameter.&quot;;
            2.718281828459045 = &lt;&lt;___;
The mathematical constant &quot;e&quot; is the unique real number such that the value of
the derivative (slope of the tangent line) of f(x) = e^x at the point x = 0 is
exactly 1.
___
            42 = &quot;The Answer to Life, the Universe, and Everything.&quot;;
        };</pre>
<pre>
        Words =
        {
            ACME = &lt;&lt;Value;
A Company [that] Makes Everything: Wile E. Coyote's supplier of equipment and gadgets.
Value
            &lt;&lt;Key = &lt;&lt;Value;
foo bar foobar
Key
[JARGON] A widely used meta-syntactic variable; see foo for etymology.  Probably
originally propagated through DECsystem manuals [...] in 1960s and early 1970s;
confirmed sightings go back to 1972. [...]
Value
        };
    };</pre>
<p>
</p>
<hr />
<h1><a name="package_details">PACKAGE DETAILS</a></h1>
<p>
</p>
<h2><a name="compile_options">Compile Options</a></h2>
<p>The format of the compiled text and the behavior of <em><a href="#item_compile">compile()</a></em> can be controlled by the
OPTIONS parameter of <em><a href="#item_write">write()</a></em>, <em><a href="#item_write_string">write_string()</a></em> etc.  The argument is a hash defining how
the Rlist text shall be formatted. The following pairs are recognized:</p>
<dl>
<dt><strong><a name="item__27precision_27__3d_3e_number">'precision' =&gt; NUMBER</a></strong>

<dd>
<p>Unless NUMBER <em>undef</em> round all numbers to the decimal places NUMBER by calling <em><a href="#item_round">round()</a></em>.  By
default NUMBER is undef, so <em><a href="#item_compile">compile()</a></em> does not round floats.</p>
</dd>
</li>
<dt><strong><a name="item__27scientific_27__3d_3e_flag">'scientific' =&gt; FLAG</a></strong>

<dd>
<p>Causes <em>compile()</em> to masquerade <em>$Data::Rlist::RoundScientific</em>; see <em><a href="#item_round">round()</a></em> for the
implications.  Alternately the <em>-RoundScientific</em> object attribute can be set; see <em><a href="#item_new">new()</a></em>.</p>
</dd>
</li>
<dt><strong><a name="item__27code_refs_27__3d_3e_flag">'code_refs' =&gt; FLAG</a></strong>

<dd>
<p>If enabled and <em><a href="#item_write">write()</a></em> encounters a <em>CODE</em> reference, calls the code, then compiles the
return value.  Disabled by default.</p>
</dd>
</li>
<dt><strong><a name="item__27threads_27__3d_3e_count">'threads' =&gt; COUNT</a></strong>

<dd>
<p>If enabled <em><a href="#item_compile">compile()</a></em> internally use multiple threads.  Note that this makes only sense on
machines with at least COUNT CPUs.</p>
</dd>
</li>
<dt><strong><a name="item__27here_docs_27__3d_3e_flag">'here_docs' =&gt; FLAG</a></strong>

<dd>
<p>If enabled strings with at least two newlines in them are written in the <a href="#here_documents">here-doc-format</a>.  Note that the string has to be terminated with a <code>&quot;\n&quot;</code> to qualify as here-document.</p>
</dd>
</li>
<dt><strong><a name="item__27outline_data_27__3d_3e_number">'outline_data' =&gt; NUMBER</a></strong>

<dd>
<p>Use <code>&quot;eol&quot;</code> (linefeed) to ``distribute data on many lines.''  Insert a linefeed after every NUMBERth
array value; 0 disables outlining.</p>
</dd>
</li>
<dt><strong><a name="item__27outline_hashes_27__3d_3e_flag">'outline_hashes' =&gt; FLAG</a></strong>

<dd>
<p>If enabled, and <code>&quot;outline_data&quot;</code> also is also enabled, prints <em>{</em> and <em>}</em> on distinct lines when
compiling Perl hashes with at least one pair.</p>
</dd>
</li>
<dt><strong><a name="item__27comma_27__3d_3e_string">'comma' =&gt; STRING</a></strong>

<dd>
<p>The comma-separator string to be used by <em><a href="#item_write_csv">write_csv()</a></em>.  The default is <code>','</code>.</p>
</dd>
</li>
<dt><strong><a name="item__27delimiter_27__3d_3e_string_2dor_2dregex">'delimiter' =&gt; STRING-OR-REGEX</a></strong>

<dd>
<p>Field-delimiter for <em><a href="#item_read_csv">read_csv()</a></em>.  The default is <code>'\s*,\s*'</code>.</p>
</dd>
</li>
</dl>
<p>The following options format the generated Rlist; normally you don't want to modify them:</p>
<dl>
<dt><strong><a name="item__27bol_tabs_27__3d_3e_count">'bol_tabs' =&gt; COUNT</a></strong>

<dd>
<p>Count of physical, horizontal TAB characters to use at the begin-of-line per indentation
level. Defaults to 1. Note that we don't use blanks, because they blow up the size of generated
text without measure.</p>
</dd>
</li>
<dt><strong><a name="item__27eol_space_27__3d_3e_string">'eol_space' =&gt; STRING</a></strong>

<dd>
<p>End-of-line string to use (the linefeed).  For example, legal values are <code>&quot;&quot;</code>, <code>&quot; &quot;</code>, <code>&quot;\r\n&quot;</code>
etc. The default is <code>&quot;\n&quot;</code>.</p>
</dd>
</li>
<dt><strong><a name="item__27paren_space_27__3d_3e_string">'paren_space' =&gt; STRING</a></strong>

<dd>
<p>String to write after <em>(</em> and <em>{</em>, and before <em>}</em> and <em>)</em> when compiling arrays and hashes.</p>
</dd>
</li>
<dt><strong><a name="item__27comma_punct_27__3d_3e_string">'comma_punct' =&gt; STRING</a></strong>

<dt><strong><a name="item__27semicolon_punct_27__3d_3e_string">'semicolon_punct' =&gt; STRING</a></strong>

<dd>
<p>Comma and semicolon strings, which shall be at least <code>&quot;,&quot;</code> and <code>&quot;;&quot;</code>.  No matter what,
<em><a href="#item_compile">compile()</a></em> will always print the <code>&quot;eol&quot;</code> string after the <code>&quot;semicolon&quot;</code> string.</p>
</dd>
</li>
<dt><strong><a name="item__27assign_punct_27__3d_3e_string">'assign_punct' =&gt; STRING</a></strong>

<dd>
<p>String to combine key/value-pairs. Defaults to <code>&quot; = &quot;</code>.  Shall be at least <code>&quot;=&quot;</code> to not violate
the compiled Rlist.</p>
</dd>
</li>
</dl>
<p>
</p>
<h3><a name="predefined_options">Predefined Options</a></h3>
<p>The <a href="#compile_options">OPTIONS</a> parameter accepted by some package functions is either a hash-ref or the name of a
predefined set:</p>
<dl>
<dt><strong><a name="item__27default_27">'default'</a></strong>

<dd>
<p>Default if writing to a file.</p>
</dd>
</li>
<dt><strong><a name="item__27string_27">'string'</a></strong>

<dd>
<p>Compact, no newlines/here-docs. Renders a ``string of data''.</p>
</dd>
</li>
<dt><strong><a name="item__27outlined_27">'outlined'</a></strong>

<dd>
<p>Optimize the compiled Rlist for maximum readability.</p>
</dd>
</li>
<dt><strong><a name="item__27squeezed_27">'squeezed'</a></strong>

<dd>
<p>Very compact, no whitespace at all. For very large Rlists.</p>
</dd>
</li>
<dt><strong><a name="item__27perl_27">'perl'</a></strong>

<dd>
<p>Compile data in Perl syntax, using <em><a href="#compile_perl__">compile_Perl()</a></em>, not <em><a href="#item_compile">compile()</a></em>.</p>
</dd>
</li>
<dt><strong><a name="item__27fast_27_or_undef">'fast' or <em>undef</em></a></strong>

<dd>
<p>Compile data as fast as possible, using <em><a href="#item_compile_fast">compile_fast()</a></em>, not compile().</p>
</dd>
</li>
</dl>
<p>All functions that define an <a href="#compile_options">OPTIONS</a> parameter implicitly call
<em><a href="#item_complete_options">complete_options()</a></em> to complete it from one of the predefined set, and <code>&quot;default&quot;</code>.
Therefore you may just define a ``lazy subset of options'' to these functions. For example,</p>
<pre>
    my $obj = new Data::Rlist(-data =&gt; $thing);
    $obj-&gt;write('thing.rls', { scientific =&gt; 1, precision =&gt; 8 });</pre>
<p>See also <a href="#item_complete_options">complete_options()</a>, <a href="#item_predefined_options">predefined_options()</a> and <em>:options</em>.</p>
<p>
</p>
<h2><a name="debugging_data__finding_selfreferences_">Debugging Data (Finding Self-References)</a></h2>
<p>Debugging (hierachical) data means breaking recursively-defined data.</p>
<p>Set <em>$Data::Rlist::MaxDepth</em> to an integer above 0 to define the depth under which <em><a href="#item_compile">compile()</a></em>
shall not venture deeper. 0 disables debugging.  When positive compilation breaks on deep
recursions caused by circular references, and on <em>stderr</em> a message like the following is printed:</p>
<pre>
    ERROR: compile2() broken in deep ARRAY(0x101aaeec) (depth = 101, max-depth = 100)</pre>
<p>The message will also be repeated as comment when the compiled Rlist is written to a file.
Furthermore <em>$Data::Rlist::Broken</em> is incremented by one - and compilation continues!  So, any
attempt to venture deeper as suggested by <em>$Data::Rlist::MaxDepth</em> in the data will be blocked,
but compilation continues above that depth.  After <em><a href="#item_write">write()</a></em> or <em><a href="#item_write_string">write_string()</a></em> returned,
the caller can check whether <em>$Data::Rlist::Broken</em> is not zero.  Then not all of the data was
compiled into text.</p>
<p>
</p>
<h2><a name="quoting_strings_that_look_like_numbers">Quoting strings that look like numbers</a></h2>
<p>Normally you don't have to care about strings, since un/quoting happens as required when
reading/compiling Rlists from Perl data.  A common problem, however, occurs when some text fragment
(string) uses the same lexicography than numbers do.</p>
<p>Printed text uses well-defined glyphs and typographic conventions, and finally the competence of
the reader to recognize numbers.  But computers need to know the exact number type and format to
recognize numbers.  Integer?  Float?  Hexadecimal?  Scientific?  Klingon?  The Perl Cookbook in
recipe 2.1 recommends the use of a regular expression to distinguish number from string scalars.
The advice illustrates how hard the problem actually is.  Not only Perl has to come over this; any
program that interprets text has to.</p>
<p>Since Perl scripts are texts that process text into more text, Perl's artful answer was to define
<em>typeless scalars</em>. Scalars hold a number, a string or a reference. Therewith Perl solves the
problem that digits, like alphabetics and punctuations, are regular ASCII codes.  So Perl defines
<em>the string</em> as the basic building block for all program data. Venturesome it then lets the
program decide <em>what strings mean</em>.  Analogical, in a printed book the reader has to decipher the
glyphs and decide what evidence they hide.</p>
<p>In Rlist, string scalars that look like numbers need to be quoted explicitly.  Otherwise, for
example, the scalar <em>$s=<code>&quot;-3.14&quot;</code></em> appears as <em>-3.14</em> in the output. Likewise <code>&quot;007324&quot;</code> is
compiled into 7324 - the text quality is lost and the scalar is read back as a number.  Of course,
this behavior is by intend, and in most cases this is just what you want. For hash keys, however,
it might be a problem.  One solution is to prefix the string by an artificial <code>&quot;_&quot;</code>:</p>
<pre>
    my $s = '-9'; $s = &quot;_$s&quot;;</pre>
<p>Since the scalar begins with a <code>&quot;_&quot;</code> it does not qualify as a number anymore, and hence is
compiled as string, and read back as string.  In the C++ implementation it will then become
<em>std::string</em>, not a <em>double</em>.  But the leading <code>&quot;_&quot;</code> has to be removed by the reading program,
which debunks this technique as a rather poor hack.  Perhaps a better solution is to explicitly
call <em>Data::Rlist::quote</em>:</p>
<pre>
    $k = -9;
    $k = Data::Rlist::quote($k); # returns qq'&quot;-9&quot;'</pre>
<pre>
    use Data::Rlist qw/:strings/;</pre>
<pre>
    $k = 3.14_15_92;
    $k = quote($k);             # returns qq'&quot;3.141592&quot;'</pre>
<p>Again, the need to quote strings that look like numbers is a problem evident only in the Perl
implementation of Rlist, since Perl is a language with weak types. As a language with very strong
typing, C++ is quasi the antipode to Perl. With the C++ implementation of Rlist then there's no
need to quote strings that look like numbers.</p>
<p>See also <em><a href="#item_write">write()</a></em>, <em><a href="#item_is_numeric">is_numeric()</a></em>, <em><a href="#item_is_name">is_name()</a></em>, <em><a href="#item_is_random_text">is_random_text()</a></em> and
<em><a href="http://en.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange">http://en.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange</a></em>.</p>
<p>
</p>
<h2><a name="speedup_compilation">Speed-up Compilation</a></h2>
<p>Much work has been spent to optimize <em>Data::Rlist</em> for speed.  Still it is implemented in pure
Perl (no XS).  A very rough estimate for Perl 5.8 is ``each MB takes one second per GHz''.  For
example, when the resulting Rlist file has a size of 13 MB, compiling it from a Perl script on a
3-GHz-PC requires about 5-7 seconds.  Compiling the same data under Solaris, on a sparcv9 processor
operating at 750 MHz, takes about 18-22 seconds.</p>
<p>
</p>
<h3><a name="explicit_quoting">Explicit Quoting</a></h3>
<p>The process of compiling can be speed up by calling <em><a href="#item_quote">quote()</a></em> explicitly on scalars. That is,
before calling <em><a href="#item_write">write()</a></em> or <em><a href="#item_write_string">write_string()</a></em>.  Large data sets may compile faster when for
scalars, that certainly not qualify as symbolic name, <em><a href="#item_quote">quote()</a></em> is called in advance:</p>
<pre>
    use Data::Rlist qw/:strings/;</pre>
<pre>
    $data{quote($key)} = $value;
        .
        .
    Data::Rlist::write(&quot;data.rlist&quot;, \%data);</pre>
<p>instead of</p>
<pre>
    $data{$key} = $value;
        .
        .
    Data::Rlist::write(&quot;data.rlist&quot;, \%data);</pre>
<p>It depends on the case whether the first variant is faster: <em><a href="#item_compile">compile()</a></em> and
<em><a href="#item_compile_fast">compile_fast()</a></em> both have to call <em><a href="#item_is_random_text">is_random_text()</a></em> on each scalar.  When the scalar is
already quoted, i.e. its first character is <code>&quot;</code>, this test ought to run faster.</p>
<p>Note that internally <em><a href="#item_is_random_text">is_random_text()</a></em> applies the precompiled regex <em>$g_re_value</em>.  But for
a given scalar <em>$s</em> the expression</p>
<pre>
    ($s !~ $Data::Rlist::g_re_value)</pre>
<p>can be up to 20% faster than the equivalent <em>is_random_text($s)</em>.</p>
<p>
</p>
<hr />
<h1><a name="package_functions">PACKAGE FUNCTIONS</a></h1>
<p>
</p>
<h2><a name="construct_objects">Construct Objects</a></h2>
<p>
</p>
<h3><a name="new____get___and_set__"><em>new()</em>, <em>get()</em> and <em>set()</em></a></h3>
<p>These are the core functions to cultivate package objects.</p>
<p>The following functions may be called also as methods: <em><a href="#item_read">read()</a></em>, <em><a href="#item_read_csv">read_csv()</a></em>,
<em><a href="#item_read_string">read_string()</a></em>, <em><a href="#item_write">write()</a></em>, <em><a href="#item_write_string">write_string()</a></em> and <em><a href="#item_keelhaul">keelhaul()</a></em>.</p>
<dl>
<dt><strong><a name="item_new"><em>new(ATTRIBUTES)</em></a></strong>

<dd>
<p>ATTRIBUTES is a hash-table defining object attributes.  Example:</p>
</dd>
<dd>
<pre>
    $self = Data::Rlist-&gt;new(-input =&gt; &quot;foo.rlist&quot;, -data =&gt; $thing);</pre>
</dd>
<dd>
<p><strong>REGULAR ATTRIBUTES</strong></p>
</dd>
<dd>
<pre>
    -input =&gt; INPUT</pre>
</dd>
<dd>
<p>Defines what to parse. INPUT defines a filename or string reference.  Applied by <em><a href="#item_read">read()</a></em>,
<em><a href="#item_read_csv">read_csv()</a></em> and <em><a href="#item_read_string">read_string()</a></em>.</p>
</dd>
<dd>
<pre>
    -data =&gt; DATA</pre>
</dd>
<dd>
<p>Defines the data to be compiled.  DATA is some Perl data.  Applied by <em><a href="#item_write">write()</a></em>,
<em><a href="#item_write_string">write_string()</a></em> and <em><a href="#item_keelhaul">keelhaul()</a></em>.</p>
</dd>
<dd>
<pre>
    -output =&gt; OUTPUT (optional)</pre>
</dd>
<dd>
<p>Defines where to put the compilation: either a filename, string-reference or <em>undef</em>.</p>
</dd>
<dd>
<pre>
    -filter =&gt; FILTER (optional)
    -filter-args =&gt; FILTER-ARGS (optional)</pre>
</dd>
<dd>
<p>Used by <em><a href="#item_read">read()</a></em> as the preprocessor on the input file. Then applied before parsing. FILTER can
be 1 to select the standard C preprocessor <em>cpp</em>.  Applied by <em><a href="#item_open_input">open_input()</a></em>.</p>
</dd>
<dd>
<pre>
    -delimiter =&gt; DELIMITER (optional)</pre>
</dd>
<dd>
<p>See <em><a href="#item_read_csv">read_csv()</a></em>.</p>
</dd>
<dd>
<pre>
    -options =&gt; OPTIONS (optional)</pre>
</dd>
<dd>
<p>Defines the <a href="#compile_options">compile options</a>.</p>
</dd>
<dd>
<pre>
    -header =&gt; STRINGS (optional)
    -columns =&gt; STRINGS (optional)</pre>
</dd>
<dd>
<p>Defines the header text (the comments) for data written to files, and the column names of CSV
files.  Used in place of the HEADER parameter of <em><a href="#item_write">write()</a></em> and COLUMNS of <em><a href="#item_write_csv">write_csv()</a></em>.</p>
</dd>
<dd>
<p><strong>ATTRIBUTES THAT MASQUERADE PACKAGE GLOBALS</strong></p>
</dd>
<dd>
<p>These attributes raise new values for package globals while object methods are executed.  The new
values are provided by an object that therewith locks the package (in which case
<em>$Data::Rlist::Locked</em> is true.)  When the method returns the previous globals are restored.</p>
</dd>
<dd>
<pre>
    -SafeCppMode =&gt; FLAG (optional)</pre>
</dd>
<dd>
<p>Used by <em><a href="#item_read">read()</a></em> to masquerade <em>$Data::Rlist::SafeCppMode</em>.</p>
</dd>
<dd>
<pre>
    -MaxDepth =&gt; INTEGER (optional)</pre>
</dd>
<dd>
<p>Used by <em><a href="#item_write">write()</a></em> to masquerade <em>$Data::Rlist::MaxDepth</em>.</p>
</dd>
<dd>
<pre>
    -RoundScientific =&gt; FLAG (optional)</pre>
</dd>
<dd>
<p>Used by <em><a href="#item_round">round()</a></em> during compilation. Masquerades <em>$Data::Rlist::RoundScientific</em>.  Note that
<em>round()</em> is only called when the <code>&quot;precision&quot;</code> option is defined.</p>
</dd>
</li>
<dt><strong><a name="item_set"><em>set(SELF[, ATTRIBUTES])</em></a></strong>

<dd>
<p>Reset or initialize object attributes (see <em><a href="#item_new">new()</a></em>).  Returns SELF.  Example:</p>
</dd>
<dd>
<pre>
    $obj-&gt;set(-input =&gt; \$str, -output =&gt; 'temp.rls', -options =&gt; 'squeezed');</pre>
</dd>
</li>
<dt><strong><a name="item_get"><em>get(SELF, NAME[, DEFAULT])</em></a></strong>

<dd>
<p>Get some object attribute.  For NAME the leading hyphen is optional.
Unless NAME exists as an attribute returns DEFAULT, or <em>undef</em>.</p>
</dd>
<dd>
<p><strong>EXAMPLES</strong></p>
</dd>
<dd>
<pre>
    $self-&gt;get('foo');          # returns $self-&gt;{-foo} or undef
    $self-&gt;get(-foo=&gt;);         # dto.
    $self-&gt;get('foo', 42);      # returns $self-&gt;{-foo} or, unless exists, 42</pre>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="interface">Interface</a></h2>
<p>Public functions to be called by users of the package.</p>
<p>
</p>
<h3><a name="read____read_csv___and_read_string__"><em>read()</em>, <em>read_csv()</em> and <em>read_string()</em></a></h3>
<dl>
<dt><strong><a name="item_read"><em>read(INPUT[, FILTER, FILTER-ARGS])</em></a></strong>

<dd>
<p>Parse data structure from INPUT.</p>
</dd>
<dd>
<p><strong>PARAMETERS</strong></p>
</dd>
<dd>
<p>INPUT shall be either</p>
</dd>
<dd>
<p>- some Rlist object created by <em><a href="#item_new">new()</a></em>,</p>
</dd>
<dd>
<p>- a string reference, in which case <em>read()</em> and <em><a href="#item_read_string">read_string()</a></em> parse Rlist text from it,</p>
</dd>
<dd>
<p>- a string scalar, in which case <em>read()</em> assumes a file to open and to parse.</p>
</dd>
<dd>
<p>See <em><a href="#item_open_input">open_input()</a></em> for details on the FILTER and FILTER-ARGS parameters, which are used to
preprocess input files before actually reading them.  When specified, and INPUT is an object, they
overload the <em>-filter</em> and <em>-filter-args</em> attributes.</p>
</dd>
<dd>
<p>When the input file cannot be <em>open</em>'d and <em>flock</em>'d this function <em>die</em>s.  Note that <em>die</em> is
Perl's mechanism to raise exceptions; they can be catched with <em>eval</em>. For example,</p>
</dd>
<dd>
<pre>
    my $host = eval { use Sys::Hostname; hostname; } || 'some unknown machine';</pre>
</dd>
<dd>
<p>This code fragment traps the <em>die</em> exception; when it was raised <em>eval</em> returns <em>undef</em>,
otherwise the result of calling <em>hostname</em>. For <em>read</em> this means</p>
</dd>
<dd>
<pre>
    $data = eval { Data::Rlist::read($tempfile) };
    print STDERR &quot;$tempfile not found, is locked or is empty&quot; unless defined $data;</pre>
</dd>
<dd>
<p><strong>RESULT</strong></p>
</dd>
<dd>
<p><em><a href="#item_read">read()</a></em> returns parsed data (reference) or <em>undef</em> if there was no data (when the length of the
physical file is greater than zero it had only comments/whitespace).</p>
</dd>
<dd>
<p>See also <em><a href="#item_parse">parse()</a></em>, <em><a href="#item_write">write()</a></em>, <em><a href="#item_write_string">write_string()</a></em>.</p>
</dd>
</li>
<dt><strong><a name="item_read_csv"><em>read_csv(INPUT[, OPTIONS, FILTER, FILTER-ARGS])</em></a></strong>

<dd>
<p><strong>PARAMETERS</strong></p>
</dd>
<dd>
<p>See <em><a href="#item_read">read()</a></em> for INPUT and <em><a href="#item_open_input">open_input()</a></em> for FILTER and FILTER-ARGS (<em>open_input()</em> is
called internally).  For example, simply pass 1 as FILTER argument to read INPUT through the
standard C preprocessor, instead of reading it directly.</p>
</dd>
<dd>
<p>The comma-delimiter is read from <a href="#compile_options">OPTIONS</a>, as <code>&quot;delimiter&quot;</code>. It defaults to
'\s*,\s*'.</p>
</dd>
<dd>
<p><strong>RESULT</strong></p>
</dd>
<dd>
<p>Returns a list of lists.  In list context a list of array references, in scalar context a reference
to such a list.  Each embedded array defines the fields in a line, and may be of variable length.</p>
</dd>
</li>
<dt><strong><a name="item_read_string"><em>read_string(INPUT)</em></a></strong>

<dd>
<p>Calls <em><a href="#item_read">read()</a></em> to read Rlist language productions from the string or string-reference INPUT.</p>
</dd>
</li>
</dl>
<p>
</p>
<h3><a name="write____write_csv___and_write_string__"><em>write()</em>, <em>write_csv()</em> and <em>write_string()</em></a></h3>
<dl>
<dt><strong><a name="item_write"><em>write(DATA[, OUTPUT, OPTIONS, HEADER])</em></a></strong>

<dd>
<p>Translates Perl data into some Rlist, i.e. into printable text.  DATA is either an object generated
by <em><a href="#item_new">new()</a></em>, or some Perl data, or <em>undef</em>.  <em>write()</em> is auto-exported as <em><a href="#item_writedata">WriteData()</a></em>.</p>
</dd>
<dd>
<p><strong>PARAMETERS</strong></p>
</dd>
<dd>
<p>When DATA is an object the Perl data to be compiled is defined by the <em>-data</em> attribute. (When
<em>-data</em> refers to another Rlist object, this other object is invoked.)  Otherwise DATA defines the
data to be compiled.</p>
</dd>
<dd>
<p>Optional OUTPUT defines where to compile to.  Defaults to the <em>-output</em> attribute when DATA
defines some <em>Data::Rlist</em> object.  Defines a filename to create, or some string-reference.  When
<em>undef</em> writes to some anonymous string.</p>
</dd>
<dd>
<p>Optional <a href="#compile_options">OPTIONS</a> arguments defines how to <a href="#item_compile">compile</a> text from DATA.  Defaults to the
<em>-options</em> attribute when DATA is an object.  When uses <em><a href="#item_compile_fast">compile_fast()</a></em>, otherwise
<em><a href="#item_compile">compile()</a></em>.</p>
</dd>
<dd>
<p>Optional HEADER is a reference to an array of strings that shall be printed literally at the top of
an output file. Defaults to the <em>-header</em> attribute when DATA is an object.</p>
</dd>
<dd>
<p><strong>RESULT</strong></p>
</dd>
<dd>
<p>When <em>write()</em> creates a file it returns 0 for failure or 1 for success.  Otherwise it returns a
string reference.</p>
</dd>
<dd>
<p><strong>EXAMPLES</strong></p>
</dd>
<dd>
<pre>
    $self = new Data::Rlist(-data =&gt; $thing, -output =&gt; $output);</pre>
</dd>
<dd>
<pre>
    $self-&gt;write;   # Write into some file (if $output is a filename) or string (if $output is a
                    # string reference).</pre>
</dd>
<dd>
<pre>
    Data::Rlist::write($thing, $output);    # dto. applying the functional interface</pre>
</dd>
<dd>
<pre>
    new Data::Rlist(-data =&gt; $self)-&gt;write; # Another way to do it.</pre>
</dd>
<dd>
<pre>
    print $self-&gt;make_string;               # Print $thing to stdout.
    print Data::Rlist::make_string($thing); # dto. applying the functional interface</pre>
</dd>
</li>
<dt><strong><a name="item_write_csv"><em>write_csv(DATA[, OUTPUT, OPTIONS, COLUMNS])</em></a></strong>

<dd>
<p>Write DATA as CSV to file or string OUTPUT.</p>
</dd>
<dd>
<p>This function automatically quotes all fields that do not look like numbers (see
<em><a href="#item_is_numeric">is_numeric()</a></em>).  Numbers are rounded to the specified precision.</p>
</dd>
<dd>
<p><em>write_csv()</em> is auto-exported as <em><a href="#item_writecsv">WriteCSV()</a></em>.</p>
</dd>
<dd>
<p><strong>PARAMETERS</strong></p>
</dd>
<dd>
<p>See <em><a href="#item_write">write()</a></em> for the DATA and OUTPUT parameters, which are semantically equal.  From <a href="#compile_options">OPTIONS</a>
is read the comma-separator (<code>&quot;comma&quot;</code>, default is <code>&quot;,&quot;</code>), the linefeed (<code>&quot;eol_space&quot;</code>, default
is <code>&quot;\n&quot;</code>) and the numeric precision (<code>&quot;precision&quot;</code>).</p>
</dd>
<dd>
<p>COLUMNS, if specified, shall be an array-ref defining the column names to be written as the first
line.</p>
</dd>
<dd>
<p>Like with <em><a href="#item_write">write()</a></em>, unless DATA refers to some <em>Data::Rlist</em> object, it shall define the data
to be compiled.  But because of the limitations of CSV files the data may not be just any Perl
data.  It must be a reference to an array of array references, where each contained array defines
the fields, e.g.</p>
</dd>
<dd>
<pre>
    [ [ a, b, c ],      # line 1
      [ d, e, f, g ],   # line 2
        .
        .
    ]</pre>
</dd>
<dd>
<p><strong>RESULT</strong></p>
</dd>
<dd>
<p>When <em>write_csv()</em> creates a file it returns 0 for failure or 1 for success.  Otherwise it returns
a string reference.</p>
</dd>
<dd>
<p><strong>EXAMPLES</strong></p>
</dd>
<dd>
<p>Functional interface:</p>
</dd>
<dd>
<pre>
    use Data::Rlist; # imports WriteCSV</pre>
</dd>
<dd>
<pre>
    WriteCSV($thing, &quot;foo.dat&quot;);</pre>
</dd>
<dd>
<pre>
    WriteCSV($thing, &quot;foo.dat&quot;, { comma =&gt; '; ' }, [qw/GBKNR VBKNR EL LaD LaD_V/]);</pre>
</dd>
<dd>
<pre>
    WriteCSV($thing, \$target_string);</pre>
</dd>
<dd>
<pre>
    $target_string_ref = WriteCSV($thing);</pre>
</dd>
<dd>
<p>Object-oriented interface:</p>
</dd>
<dd>
<pre>
    $object = new Data::Rlist(-data =&gt; $thing, -output =&gt; &quot;foo.dat&quot;,
                              -options =&gt; { comma =&gt; '; ' },
                              -columns =&gt; [qw/GBKNR VBKNR EL LaD LaD_V/]);
    $object-&gt;write_csv;     # Write $thing as CSV to foo.dat
    $object-&gt;write;         # Write $thing as Rlist to foo.dat</pre>
</dd>
<dd>
<pre>
    $object-&gt;set(-output =&gt; \$target_string);
    $object-&gt;write_csv;     # Write $thing as CSV to $target_string</pre>
</dd>
</li>
<dt><strong><a name="item_write_string"><em>write_string(DATA[, OPTIONS])</em></a></strong>

<dd>
<p>Like <em><a href="#item_write">write()</a></em> but always compiles to a new string to which it returns a reference.  In an
object this function does not use <em>-output</em>, even when this attribute defines a string reference.
It also won't use <em>-options</em>. Instead it uses the predefined options set <a href="#predefined_options"><code>&quot;string&quot;</code></a> to render a very compact Rlist without newlines and here-docs.</p>
</dd>
</li>
</dl>
<p>
</p>
<h3><a name="make_string___and_keelhaul__"><em>make_string()</em> and <em>keelhaul()</em></a></h3>
<dl>
<dt><strong><a name="item_make_string"><em>make_string(DATA[, OPTIONS])</em></a></strong>

<dd>
<p>Print Perl DATA to a string and return its value.  This function actually is an alias for</p>
</dd>
<dd>
<pre>
    ${Data::Rlist::write_string(DATA, OPTIONS)}</pre>
</dd>
<dd>
<p><a href="#compile_options">OPTIONS</a> default to <a href="#predefined_options"><code>&quot;default&quot;</code></a>, which means that in an
object context <em>make_string()</em> will never use the <em>-options</em> attribute.</p>
</dd>
<dd>
<p><strong>EXAMPLES</strong></p>
</dd>
<dd>
<pre>
    print &quot;\n\$data: &quot;, Data::Rlist::make_string($data);</pre>
</dd>
<dd>
<pre>
    $self = new Data::Rlist(-data =&gt; $thing);</pre>
</dd>
<dd>
<pre>
    print &quot;\n\$thing: &quot;, $self-&gt;make_string;</pre>
</dd>
</li>
<dt><strong><a name="item_keelhaul"><em>keelhaul(DATA[, OPTIONS])</em></a></strong>

<dd>
<p>Do a deep copy of DATA according to <a href="#compile_options">OPTIONS</a>.  DATA is some Perl data, or some <em><a href="#item_new">Data::Rlist object</a></em>.</p>
</dd>
<dd>
<p><em>keelhaul()</em> works by first compile DATA to text, then restoring the data from the text.  The text
had been carefully built according to certain <a href="#compile_options">Compile Options</a>. Hence, by ``keelhauling data'',
one can adjust the accuracy of numbers, break circular-references and drop <em>\*foo{THING}</em>s.</p>
</dd>
<dd>
<p><strong>EXAMPLES</strong></p>
</dd>
<dd>
<p>When <em>keelhaul()</em> is called in an array context it also returns the text from which the copy had
been built:</p>
</dd>
<dd>
<pre>
    $deep_copy = Data::Rlist::keelhaul($thing);</pre>
</dd>
<dd>
<pre>
    ($deep_copy, $rlist_text) = Data::Rlist::keelhaul($thing);</pre>
</dd>
<dd>
<pre>
    $deep_copy = new Data::Rlist(-data =&gt; $thing)-&gt;keelhaul;</pre>
</dd>
<dd>
<p>Bring all numbers in DATA to a certain accuracy:</p>
</dd>
<dd>
<pre>
    $thing = { foo =&gt; [.00057260, -1.6804e-4] };</pre>
</dd>
<dd>
<pre>
    $deep_copy = Data::Rlist::keelhaul($thing, { precision =&gt; 4 });</pre>
</dd>
<dd>
<p>which copies <em>$thing</em> into</p>
</dd>
<dd>
<pre>
    { foo =&gt; [0.0006, -0.0002] }</pre>
</dd>
<dd>
<p>All number scalars where rounded to 4 decimal places, so they're finally comparable as
floating-point numbers (see <em><a href="#item_equal">equal()</a></em> for a discussion), One can also convert all floats to
integers:</p>
</dd>
<dd>
<pre>
    $self = Data::Rlist-&gt;new(-data =&gt; $thing);</pre>
</dd>
<dd>
<pre>
    $deep_copy = $self-&gt;keelhaul({precision =&gt; 0});</pre>
</dd>
<dd>
<p><strong>NOTES</strong></p>
</dd>
<dd>
<p>It was said before that keelhauling is a working method to create a deep copy of Perl
data. <em>keelhaul()</em> won't throw <em>die</em> nor return an error, but be prepared for the following
effects:</p>
</dd>
<ul>
<li>
<p><em>ARRAY</em>, <em>HASH</em>, <em>SCALAR</em> and <em>REF</em> references were compiled, whether blessed or not.
Depending on the compile options <em>CODE</em> references were called, deparsed back into their function
bodies, or dropped.</p>
</li>
<li>
<p><em>IO</em>, <em>GLOB</em> and <em>FORMAT</em> references have been converted into their plain typenames (see
<em><a href="#item_compile">compile()</a></em>).</p>
</li>
<li>
<p><em>undef</em>'d array elements had been converted into the default scalar value <code>&quot;&quot;</code>.</p>
</li>
<li>
<p>Compile options are considered, such as implicit rounding of floats.</p>
</li>
<li>
<p>Anything deeper than <em>$Data::Rlist::MaxDepth</em> is thrown away (again, see <em><a href="#item_compile">compile()</a></em>).</p>
</li>
<li>
<p>Since compiling does not store type information, <em>keelhaul()</em> will turn blessed references into
barbars again. No special methods to ``freeze'' and ``thaw'' an object is called before compiling or
after parsing it. Instead the copy is a copy made from what any object in a computer ultimately
consists of: strings and numbers.</p>
</li>
</ul>
<dt><strong><a name="item_predefined_options"><em>predefined_options([PREDEF-NAME])</em></a></strong>

<dd>
<p>Get <em>%Data::Rlist::PredefinedOptions{PREDEF-NAME}</em>.  PREDEF-NAME defaults to
<a href="#predefined_options"><code>&quot;default&quot;</code></a>, the options for writing files.</p>
</dd>
</li>
<dt><strong><a name="item_complete_options"><em>complete_options([OPTIONS[, PREDEF-NAME]])</em></a></strong>

<dd>
<p>Completes <a href="#compile_options">OPTIONS</a> (hash or name) using the predefined set PREDEF-NAME.
(defaults to <a href="#predefined_options"><code>&quot;default&quot;</code></a>).  For example,</p>
</dd>
<dd>
<pre>
    complete_options({ precision =&gt; 0 }, 'squeezed')</pre>
</dd>
<dd>
<p>combines the predefined options for <a href="#predefined_options"><code>&quot;squeezed&quot;</code></a> text (no whitespace at
all, no here-docs, numbers are rounded to a precision of 6) with a numeric precision of 0.  This
converts all floats to integers.</p>
</dd>
<dd>
<p>Returns a reference to a new hash of <a href="#compile_options">Compile Options</a>.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="implementation">Implementation</a></h2>
<p>
</p>
<h3><a name="open_input___and_close_input__"><em>open_input()</em> and <em>close_input()</em></a></h3>
<dl>
<dt><strong><a name="item_open_input"><em>open_input(INPUT[, FILTER, FILTER-ARGS])</em></a></strong>

<dt><strong><a name="item_close_input"><em>close_input()</em></a></strong>

<dd>
<p>Open/close Rlist text file or string INPUT for parsing. Used internally by <em><a href="#item_read">read()</a></em> and
<em><a href="#item_read_csv">read_csv()</a></em>.</p>
</dd>
<dd>
<p><strong>PREPROCESSING</strong></p>
</dd>
<dd>
<p>If specified the function preprocesses the INPUT file using FILTER, before actually reading the
file.  Use the special value 1 for FILTER to select the default C preprocessor (precisely, <em>gcc -E
-Wp,-C</em>).  FILTER-ARGS is an optional string of additional command-line arguments appended to
FILTER.  For example,</p>
</dd>
<dd>
<pre>
    my $foo = read(&quot;foo&quot;, 1, &quot;-DEXTRA&quot;)</pre>
</dd>
<dd>
<p>eventually does not parse <em>foo</em>, but the output of the command</p>
</dd>
<dd>
<pre>
    gcc -E -Wp,-C -DEXTRA foo</pre>
</dd>
<dd>
<p>Hence within <em>foo</em> C-preprocessor-statements are allowed:</p>
</dd>
<dd>
<pre>
    {
    #ifdef EXTRA
    #include &quot;extra.rlist&quot;
    #endif</pre>
</dd>
<dd>
<pre>
        123 = (1, 2, 3);
        foobar = {
            .
            .</pre>
</dd>
<dd>
<p><strong>SAFE CPP MODE</strong></p>
</dd>
<dd>
<p>This slightly esoteric mode involves <em>sed</em> and a temporary file.  It is enabled by setting
<em>$Data::Rlist::SafeCppMode</em> to 1 (the default).  It protects single-line <em>#</em>-comments when FILTER
begins with either <em>gcc</em>, <em>g++</em> or <em>cpp</em>.  <em><a href="#item_open_input">open_input()</a></em> then additionally runs <em>sed</em> to
convert all input lines beginning with whitespace plus the <em>#</em> character. Only the following
<em>cpp</em>-commands are excluded, and only when they appear in column 1:</p>
</dd>
<dd>
<p>- <em>#include</em> and <em>#pragma</em></p>
</dd>
<dd>
<p>- <em>#define</em> and <em>#undef</em></p>
</dd>
<dd>
<p>- <em>#if</em>, <em>#ifdef</em>, <em>#else</em> and <em>#endif</em>.</p>
</dd>
<dd>
<p>For all other lines <em>sed</em> converts <em>#</em> into <em>##</em>. This prevents the C preprocessor from
evaluating them.  But because of Perl's limited <em>open()</em> function, which isn't able to open
arbitary pipes, the invocation of <em>sed</em> requires a temporary file. The file is simply created by
appending <code>&quot;.tmp&quot;</code> to the pathname passed in INPUT.  <em><a href="#item_lexln">lexln()</a></em>, the function that feeds the
lexical scanner with lines, then converts <em>##</em> back into comment lines.</p>
</dd>
<dd>
<p>Alternately, use <em>//</em> and <em>/* */</em> comments and set <em>$Data::Rlist::SafeCppMode</em> to 0.</p>
</dd>
</li>
</dl>
<p>
</p>
<h3><a name="lex___and_parse__"><em>lex()</em> and <em>parse()</em></a></h3>
<dl>
<dt><strong><a name="item_lex"><em>lex()</em></a></strong>

<dd>
<p>Lexical scanner.  Called by <em><a href="#item_parse">parse()</a></em> to split the current line into tokens.  <em>lex()</em> reads
<em>#</em> or <em>//</em> single-line-comment and <em>/* */</em> multi-line-comment as regular white-spaces.
Otherwise it returns tokens according to the following table:</p>
</dd>
<dd>
<pre>
    RESULT      MEANING
    ------      -------
    '{' '}'     Punctuation
    '(' ')'     Punctuation
    ','         Operator
    ';'         Punctuation
    '='         Operator
    'v'         Constant value as number, string, list or hash
    '??'        Error
    undef       EOF</pre>
</dd>
<dd>
<p><em>lex()</em> appends all here-doc-lines with a newline character. For example,</p>
</dd>
<dd>
<pre>
        &lt;&lt;test1
        a
        b
        test1</pre>
</dd>
<dd>
<p>is effectively read as <code>&quot;a\nb\n&quot;</code>, which is the same value as the equivalent here-doc in Perl has.
Hence the purpose of the last character (the newline in the last line) is not just to separate the
last line from the delimiter.  As a consequence, not all strings can be encoded as a here-doc.  For
example, it might not be quite obvious to many programmers that <code>&quot;foo\nbar&quot;</code> has no
here-doc-equivalent.</p>
</dd>
</li>
<dt><strong><a name="item_lexln"><em>lexln()</em></a></strong>

<dd>
<p>Read the next line of text from the input.  Return 0 if <em><a href="#item_at_eof">at_eof()</a></em>, 1 otherwise.</p>
</dd>
</li>
<dt><strong><a name="item_at_eof"><em>at_eof()</em></a></strong>

<dd>
<p>Return true if current input file / string array is exhausted, false otherwise.</p>
</dd>
</li>
<dt><strong><a name="item_parse"><em>parse()</em></a></strong>

<dd>
<p>Read Rlist language productions from current input, defined by package variables.  This is a fast,
non-recursive parser driven by the parser map <em>%Data::Rlist::Rules</em>.  See also <em><a href="#item_lex">lex()</a></em>.</p>
</dd>
</li>
</dl>
<p>
</p>
<h3><a name="errors____broken___and_missing_input__"><em>errors()</em>, <em>broken()</em> and <em>missing_input()</em></a></h3>
<dl>
<dt><strong><a name="item_errors"><em>errors([SELF])</em></a></strong>

<dd>
<p>Returns the number of syntax errors that occurred in the last call to <em><a href="#item_parse">parse()</a></em>.  When called
as method (i.e. SELF is defined) returns the number of syntax errors that occured for the last time
an object had called <em><a href="#item_read">read()</a></em>.</p>
</dd>
</li>
<dt><strong><a name="item_broken"><em>broken([SELF])</em></a></strong>

<dd>
<p>Return the number of times the last <em><a href="#item_compile">compile()</a></em> crossed the zenith of
<em>$Data::Rlist::MaxDepth</em>. When called as method returns the information for the last time an
object had called <em><a href="#item_read">read()</a></em>.</p>
</dd>
</li>
<dt><strong><a name="item_missing_input"><em>missing_input([SELF])</em></a></strong>

<dd>
<p>Return true when the last call to <em><a href="#item_parse">parse()</a></em> yielded <em>undef</em> because there was nothing to
parse.  Otherwise, when <em>parse()</em> returned <em>undef</em>, this means there was some syntax error.
<em>parse()</em> is called internally by <em><a href="#item_read">read()</a></em>.  When called as method returns the information
for the last time an object had called <em><a href="#item_read">read()</a></em>.</p>
</dd>
</li>
</dl>
<p>
</p>
<h3><a name="compile__"><em>compile()</em></a></h3>
<dl>
<dt><strong><a name="item_compile"><em>compile(DATA[, OPTIONS, FH])</em></a></strong>

<dd>
<p>Build Rlist from DATA.  DATA is a Perl scalar as number, string or reference.  When FH is defined
compile directly to this file and return 1.  Otherwise (FH is <em>undef</em>) build a string and return a
reference to it.</p>
</dd>
<dl>
<dt><strong><a name="item_reference_2dtypes_scalar_2c_hash_2c_array_and_ref_">Reference-types <em>SCALAR</em>, <em>HASH</em>, <em>ARRAY</em> and <em>REF</em>.</a></strong>

<dd>
<p>Compiled into text, whether blessed or not.</p>
</dd>
</li>
<dt><strong><a name="item_reference_2dtypes_code">Reference-types <em>CODE</em></a></strong>

<dd>
<p>How <em>CODE</em> references are compiled depends on the <code>&quot;code_refs&quot;</code> flag defined by <a href="#compile_options">OPTIONS</a>. Legal values are <em>undef</em>, <code>&quot;call&quot;</code> (the default) and <code>&quot;deparse&quot;</code>.</p>
</dd>
<dd>
<p>When <code>&quot;code-ref&quot;</code>'s value is <em>undef</em> compiles <code>&quot;?CODE?&quot;</code>. A value of <code>&quot;call&quot;</code> calls the sub and
compiles its result.  <code>&quot;deparse&quot;</code> serializes the code using <em>B::Deparse</em>, which reproduces the
Perl source of the sub. Note that it then makes sense to enable <code>&quot;here_docs&quot;</code>, because otherwise
the deparsed code will be in one string with LFs quoted as <code>&quot;\012&quot;</code>.</p>
</dd>
</li>
<dt><strong><a name="item_reference_2dtypes_glob_2c_io_and_format">Reference-types <em>GLOB</em>, <em>IO</em> and <em>FORMAT</em></a></strong>

<dd>
<p>Reference-types that cannot be compiled are <em>GLOB</em> (typeglob-refs), <em>IO</em> (file- and directory
handles) and <em>FORMAT</em>.  These are then converted into <code>&quot;?GLOB?&quot;</code>, <code>&quot;?IO?&quot;</code> and
<code>&quot;?FORMAT?&quot;</code>.</p>
</dd>
</li>
<dt><strong><a name="item_background_3a_a_short_story_of__22typeglobs_22">Background: A Short Story of ``Typeglobs''</a></strong>

<dd>
<p>Typeglobs are an idiosyncracy of Perl.  Perl uses a symbol table per package (namespace) to map
identifier names (like <code>&quot;foo&quot;</code> without sigil) to values.  The symbol table is stored in the hash,
named like the package with two colons appended. The main symbol table's name is thus <em>%main::</em>,
or <em>%::</em>.</p>
</dd>
<dd>
<p>For example, in the name <code>&quot;foo&quot;</code> in symbol tables is mapped to the <em>typeglob</em> value <em>*foo</em>.  The
typeglob object implements <em>$foo</em> (the scalar value), <em>@foo</em> (the list value), <em>%foo</em> (the hash
value), <em>&amp;foo</em> (the code value) and <em>foo</em> (the file handle or the format specifier).  All types
may coexist, so modifying <em>$foo</em> won't change <em>%foo</em>.  But <em>*baz = *foo</em> overwrites, or creates,
the symbol table entry <code>&quot;baz&quot;</code>. (The value of <code>&quot;baz&quot;</code> will be another <em>typeglob</em> object.)</p>
</dd>
<dd>
<p>Typeglobs are <em>variant</em>s that can store multiple concrete values. The sigil <em>*</em> serves as
wildcard for the other sigils <em>%</em>, <em>@</em>, <em>$</em> and <em>&amp;</em>. (Note: a <em>sigil</em> is a symbol created for
a specific magical purpose; the name derives from the latin <em>sigilum</em> = seal.)  So, the fancy-free
Perl primitives are <em>\*foo</em>, a typeglob-ref, and <em>\*::</em>, a typeglob-table-ref.</p>
</dd>
<dd>
<pre>
    \*foo;              # yields 'GLOB(0xNNN)'
    \*::;               # yields 'GLOB(0xNNN)'
    die unless \*foo == *foo{GLOB}; # never fires</pre>
</dd>
<dd>
<p><em>\*foo</em> eventually is Perl's way to prove the existence of <em>foo</em>, the symbol. <em>*foo</em> is the
internal ``proxy'' that tells <em>perl</em> what you really mean, at this moment, when you say <code>&quot;foo&quot;</code>.
In core this proxy is a hash-table, hence another way to say <em>\*foo</em> is <em>*foo{GLOB}</em>, which
eventually refers to <code>&quot;foo&quot;</code>'s incarnation as typeglob <code>*foo</code>.</p>
</dd>
<dd>
<p>In other words: with typeglobs you reach the bedrock of <em>perl</em>, where the spade bends back.  Note,
however, that after calling <em><a href="#item_compile">compile()</a></em> typeglob-refs have gone up in smoke.</p>
</dd>
</li>
<dt><strong><a name="item_undef"><em>undef</em></a></strong>

<dd>
<p><em>undef</em>'d values in arrays are compiled into the default Rlist <code>&quot;&quot;</code>.</p>
</dd>
</li>
</dl>
<dt><strong><a name="item_compile_fast"><em>compile_fast(DATA)</em></a></strong>

<dd>
<p>Assemble Rlist from Perl data DATA as fast as actually possible with pure Perl.  Reference-types
<em>SCALAR</em>, <em>HASH</em>, <em>ARRAY</em> and <em>REF</em> are compiled into text, whether blessed or not.  <em>CODE</em>,
<em>GLOB</em>, <em>IO</em> and <em>FORMAT</em> are compiled as <code>&quot;?CODE?&quot;</code>, <code>&quot;?IO?&quot;</code>, <code>&quot;?GLOB?&quot;</code> and <code>&quot;?FORMAT?&quot;</code>.
<em>undef</em> values in arrays are compiled into the default Rlist <code>&quot;&quot;</code>.</p>
</dd>
<dd>
<p>The main difference to <em><a href="#item_compile">compile()</a></em> is that <em>compile_fast()</em> considers no <a href="#compile_options">compile options</a>. Thus it cannot call code, implicitly round numbers etc., and cannot
detect recursively-defined data.</p>
</dd>
<dd>
<p><em>compile_fast()</em> returns a reference to the compiled string, which is a reference to a unique
package variable. Subsequent calls to <em>compile_fast()</em> therefore reassign this variable.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="auxiliary_functions">AUXILIARY FUNCTIONS</a></h1>
<p>The utility functions in this section are generally useful when handling stringified data.  These
functions are either very fast, or smart, or both.  For example, <em><a href="#item_quote">quote()</a></em>, <em><a href="#item_unquote">unquote()</a></em>,
<em><a href="#item_escape">escape()</a></em> and <em><a href="#item_unescape">unescape()</a></em> internally use precompiled regexes and precomputed ASCII
tables; so employing these functions is probably faster then using own variants.</p>
<p>
</p>
<h2><a name="is_numeric____is_name___and_is_random_text__"><em>is_numeric()</em>, <em>is_name()</em> and <em>is_random_text()</em></a></h2>
<dl>
<dt><strong><a name="item_is_integer"><em>is_integer(SCALAR-REF)</em></a></strong>

<dd>
<p>Returns true when a scalar looks like an +/- integer constant.  The function applies the compiled
regex <em>$Data::Rlist::g_re_integer</em>.</p>
</dd>
</li>
<dt><strong><a name="item_is_numeric"><em>is_numeric(SCALAR-REF)</em></a></strong>

<dd>
<p>Test for strings that look like numbers. <em>is_numeric()</em> can be used to test whether a scalar looks
like a integer/float constant (numeric literal). The function applies the compiled regex
<em>$Data::Rlist::g_re_float</em>.  Note that it doesn't match</p>
</dd>
<dd>
<p>- the IEEE 754 notations of Infinite and NaN,</p>
</dd>
<dd>
<p>- leading or trailing whitespace,</p>
</dd>
<dd>
<p>- lexical conventions such as the <code>&quot;0b&quot;</code> (binary), <code>&quot;0&quot;</code> (octal), <code>&quot;0x&quot;</code> (hex) prefix to denote a
  number-base other than decimal, and</p>
</dd>
<dd>
<p>- Perls' ``legible numbers'', e.g. <em>3.14_15_92</em></p>
</dd>
<dd>
<p>See also</p>
</dd>
<dd>
<pre>
    perldoc -q &quot;whether a scalar is a number&quot;</pre>
</dd>
</li>
<dt><strong><a name="item_is_name"><em>is_name(SCALAR-REF)</em></a></strong>

<dd>
<p>Test for symbolic names.  <em>is_name()</em> can be used to test whether a scalar looks like a symbolic
name.  Such strings need not to be quoted.  Rlist defines symbolic names as a superset of C
identifier names:</p>
</dd>
<dd>
<pre>
    [a-zA-Z_0-9]                    # C/C++ character set for identifiers
    [a-zA-Z_0-9\-/\~:\.@]           # Rlist character set for symbolic names</pre>
</dd>
<dd>
<pre>
    [a-zA-Z_][a-zA-Z_0-9]*                  # match C/C++ identifier
    [a-zA-Z_\-/\~:@][a-zA-Z_0-9\-/\~:\.@]*  # match Rlist symbolic name</pre>
</dd>
<dd>
<p>For example, scoped/structured names such as <em>std::foo</em>, <em>msg.warnings</em>, <em>--verbose</em>,
<em>calculation-info</em> need not be quoted. (But if they're quoted their value is exactly the same.)
Note that <em>is_name()</em> does not catch leading or trailing whitespace. Another restriction is that
<code>&quot;.&quot;</code> cannot be used as first character, since it could also begin a number.</p>
</dd>
</li>
<dt><strong><a name="item_is_random_text"><em>is_random_text(SCALAR-REF)</em></a></strong>

<dd>
<p><em>is_random_text()</em> returns true if the scalar is neither a symbolic name nor a number, nor is
double-quoted.  When this function returns true, then <em><a href="#item_compile">compile()</a></em> and <em><a href="#item_compile_fast">compile_fast()</a></em>
would call <em><a href="#item_quote">quote()</a></em> on the scalar.  In Rlists, all scalars need to be quoted, expect those
that are</p>
</dd>
<dd>
<p>- already quoted,</p>
</dd>
<dd>
<p>- look like C identifiers or <a href="#item_is_name">symbolic names</a>,</p>
</dd>
<dd>
<p>- look like C <a href="#item_is_numeric">number constants</a>.</p>
</dd>
<dd>
<p>Warning: <em>is_random_text()</em> makes no further test whether a string consists of characters that
actually require escaping. That is, it returns also true on strings that do not adhere to
7-bit-ASCII, by defining characters &lt;32 and &gt;127.</p>
</dd>
<dd>
<p>See also <em><a href="#item_is_numeric">is_numeric()</a></em> and <em><a href="#item_is_name">is_name()</a></em>.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="quote____escape___and_unhere__"><em>quote()</em>, <em>escape()</em> and <em>unhere()</em></a></h2>
<dl>
<dt><strong><a name="item_quote"><em>quote(TEXT)</em></a></strong>

<dt><strong><a name="item_escape"><em>escape(TEXT)</em></a></strong>

<dd>
<p>Converts TEXT into 7-bit-ASCII.  All characters not in the set of the 95 printable ASCII characters
are <em>escape</em>d.  The difference between the two functions is that <em>quote()</em> additionally places
TEXT into double-quotes.</p>
</dd>
<dd>
<p>The following ASCII codes will be converted to escaped octal numbers, i.e. 3 digits prefixed by a
slash:</p>
</dd>
<dd>
<pre>
    0x00 to 0x1F
    0x80 to 0xFF
    &quot; ' \</pre>
</dd>
<dd>
<p>For example, <em>quote(qq'``Fr&uuml;her Mittag\n''')</em> returns <code>&quot;\&quot;Fr\374her Mittag\012\&quot;&quot;</code>, while
<em>escape()</em> returns <code>\&quot;Fr\374her Mittag\012\&quot;</code></p>
</dd>
</li>
<dt><strong><a name="item_maybe_quote"><em>maybe_quote(TEXT)</em></a></strong>

<dd>
<p>Return <em>quote(TEXT)</em> if <em><a href="#item_is_random_text">is_random_text(TEXT)</a></em>; otherwise (TEXT defines a symbolic name or
number) return TEXT.</p>
</dd>
</li>
<dt><strong><a name="item_unquote"><em>unquote(TEXT)</em></a></strong>

<dt><strong><a name="item_unescape"><em>unescape(TEXT)</em></a></strong>

<dd>
<p>Reverses <em><a href="#item_quote">quote()</a></em> and <em><a href="#item_escape">escape()</a></em>.</p>
</dd>
</li>
<dt><strong><a name="item_unhere"><em>unhere(HERE-DOC-STRING[, COLUMNS, FIRSTTAB, DEFAULTTAB])</em></a></strong>

<dd>
<p>HERE-DOC-STRING shall be a <a href="#here_documents">here-document</a>. The function checks whether each line
begins with a common prefix, and if so, strips that off.  If no prefix it takes the amount of
leading whitespace found the first line and removes that much off each subsequent line.</p>
</dd>
<dd>
<p>Unless COLUMNS is defined returns the new here-doc-string. Otherwise, takes the string and
reformats it into a paragraph having no line more than COLUMNS characters long. FIRSTTAB will be
the indent for the first line, DEFAULTTAB the indent for every subsequent line. Unless passed,
FIRSTTAB and DEFAULTTAB default to the empty string <code>&quot;&quot;</code>.</p>
</dd>
<dd>
<p>This function combines recipes 1.11 and 1.12 from the Perl Cookbook.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="split_quoted__"><em>split_quoted()</em></a></h2>
<dl>
<dt><strong><a name="item_split_quoted"><em>split_quoted(INPUT[, DELIMITER])</em></a></strong>

<dt><strong><a name="item_parse_quoted"><em>parse_quoted(INPUT[, DELIMITER])</em></a></strong>

<dd>
<p>Divide the string INPUT into a list of strings.  DELIMITER is a regular expression specifying where
to split (default: <code>'\s+'</code>).  The function won't split at DELIMITERs inside quotes, or which are
backslashed.  For example, to split INPUT at commas use <code>'\s*,\s*'</code>.</p>
</dd>
<dd>
<p><em>parse_quoted()</em> works like <em>split_quoted()</em> but additionally removes all quotes and backslashes
from the splitted fields.  Both functions effectively simplify the interface of
<em>Text::ParseWords</em>.  In an array context both return a list of substrings, otherwise the count of
substrings. An empty array is returned in case of unbalanced <code>&quot;</code> quotes, e.g.
<em>split_quoted(<code>foo,&quot;bar</code>)</em> returns <em>()</em>.</p>
</dd>
<dd>
<p><strong>EXAMPLES</strong></p>
</dd>
<dd>
<p><em>split_quoted()</em>:</p>
</dd>
<dd>
<pre>
    sub split_and_list($) {
        print ($i++, &quot; '$_'\n&quot;) foreach split_quoted(shift)
    }</pre>
</dd>
<dd>
<pre>
    split_and_list(q(&quot;fee foo&quot; bar))</pre>
</dd>
<dd>
<pre>
        0 '&quot;fee foo&quot;'
        1 'bar'</pre>
</dd>
<dd>
<pre>
    split_and_list(q(&quot;fee foo&quot;\ bar))</pre>
</dd>
<dd>
<pre>
        0 '&quot;fee foo&quot;\ bar'</pre>
</dd>
<dd>
<p>The default DELIMITER <code>'\s+'</code> handles newlines.  <em>split_quoted(<code>&quot;foo\nbar\n&quot;</code>)</em> returns
<em>('foo','bar','')</em> and hence can be used to to split a large string of un<em>cho(m)p</em>'d input lines
into words:</p>
</dd>
<dd>
<pre>
    split_and_list(&quot;foo  \r\n bar\n&quot;)</pre>
</dd>
<dd>
<pre>
        0 'foo'
        1 'bar'
        2 ''</pre>
</dd>
<dd>
<p>The DELIMITER matches everywhere outside of quoted constructs, so in case of the default <code>'\s+'</code>
you may want to remove heading/trailing whitespace. Consider</p>
</dd>
<dd>
<pre>
    split_and_list(&quot;\nfoo&quot;)
    split_and_list(&quot;\tfoo&quot;)</pre>
</dd>
<dd>
<pre>
        0 ''
        1 'foo'</pre>
</dd>
<dd>
<p>and</p>
</dd>
<dd>
<pre>
    split_and_list(&quot; foo &quot;)</pre>
</dd>
<dd>
<pre>
        0 ''
        1 'foo'
        2 ''</pre>
</dd>
<dd>
<p><em>parse_quoted()</em>:</p>
</dd>
<dd>
<pre>
    sub parse_and_list($) {
        print ($i++, &quot; '$_'\n&quot;) foreach parse_quoted(shift)
    }</pre>
</dd>
<dd>
<pre>
    parse_and_list(q(&quot;fee foo&quot; bar))</pre>
</dd>
<dd>
<pre>
        0 'fee foo'
        1 'bar'</pre>
</dd>
<dd>
<pre>
    parse_and_list(q(&quot;fee foo&quot;\ bar))</pre>
</dd>
<dd>
<pre>
        0 'fee foo bar'</pre>
</dd>
<dd>
<p><strong>MORE EXAMPLES</strong></p>
</dd>
<dd>
<p>String <code>'field\ one  &quot;field\ two&quot;'</code>:</p>
</dd>
<dd>
<pre>
    ('field\ one', '&quot;field\ two&quot;')  # split_quoted
    ('field one', 'field two')      # parse_quoted</pre>
</dd>
<dd>
<p>String <code>'field\,one, field&quot;, two&quot;'</code> with a DELIMITER of <code>'\s*,\s*'</code>:</p>
</dd>
<dd>
<pre>
    ('field\,one', 'field&quot;, two&quot;')  # split_quoted
    ('field,one', 'field, two')     # parse_quoted</pre>
</dd>
<dd>
<p>Split a large string <em>$soup</em> (mnemonic: possibly ``slurped'' from a file) into lines, at LF or
CR+LF:</p>
</dd>
<dd>
<pre>
    @lines = split_quoted($soup, '\r*\n');</pre>
</dd>
<dd>
<p>Then transform all <em>@lines</em> by correctly splitting each line into ``naked'' values:</p>
</dd>
<dd>
<pre>
    @table = map { [ parse_quoted($_, '\s*,\s') ] } @lines</pre>
</dd>
<dd>
<p>Here is some more complete code to parse a <em>.csv</em>-file with quoted fields, escaped commas:</p>
</dd>
<dd>
<pre>
    open my $fh, &quot;foo.csv&quot; or die $!;
    local $/;                   # enable localized slurp mode
    my $content = &lt;$fh&gt;;        # slurp whole file at once
    close $fh;
    my @lines = split_quoted($content, '\r*\n');
    die q(unbalanced &quot; in input) unless @lines;
    my @table = map { [ map { parse_quoted($_, '\s*,\s') } ] } @lines</pre>
</dd>
<dd>
<p>Note, however, that the <em><a href="#item_read_csv">read_csv()</a></em> function already reads <em>.csv</em>-file perfectly well.</p>
</dd>
<dd>
<p>A nice way to make sure what <em>split_quoted()</em> and <em>parse_quoted()</em> return is using
<em>deep_compare()</em>.  For example, the following code shall never die:</p>
</dd>
<dd>
<pre>
    croak if deep_compare([split_quoted(&quot;fee fie foo&quot;)], ['fee', 'fie', 'foo']);
    croak if deep_compare( parse_quoted('&quot;fee fie foo&quot;'), 1);</pre>
</dd>
<dd>
<p>The 2nd call to <em><a href="#item_parse_quoted">parse_quoted()</a></em> happens in scalar context, hence shall return 1 because
there's one string to parse.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="equal___and_round__"><em>equal()</em> and <em>round()</em></a></h2>
<dl>
<dt><strong><a name="item_equal"><em>equal(NUM1, NUM2[, PRECISION])</em></a></strong>

<dt><strong><a name="item_round"><em>round(NUM1[, PRECISION])</em></a></strong>

<dd>
<p>Compare and round floating-point numbers. <em><a href="#item_equal">equal()</a></em> returns true if NUM1 and NUM2 are equal to
PRECISION (default: 6) number of decimal places.  NUM1 and NUM2 are string- or number scalars.</p>
</dd>
<dd>
<p>Normally <em>round()</em> will return a number in fixed-point notation.  When the package-global
<em>$Data::Rlist::RoundScientific</em> is true <em>round()</em> formats the number in either normal or
exponential (scientific) notation, whichever is more appropriate for its magnitude.  This differs
slightly from fixed-point notation in that insignificant zeroes to the right of the decimal point
are not included. Also, the decimal point is not included on whole numbers.  For example,
<em><a href="#item_round">round(42)</a></em> does not return 42.000000, and <em>round(0.12)</em> returns 0.12, not 0.120000.  This
behavior is especially welcome when scientific notation was selected.  For example, note that</p>
</dd>
<dd>
<pre>
    sprintf(&quot;%.6g\n&quot;, 2006073104)</pre>
</dd>
<dd>
<p>yields 2.00607e+09, which looses digits.</p>
</dd>
<dd>
<p><strong>MACHINE ACCURACY</strong></p>
</dd>
<dd>
<p>One needs <em><a href="#item_equal">equal()</a></em> to compare floats because IEEE 754 single- and double precision
implementations are not absolute - in contrast to the numbers they represent.  In all machines
non-integer numbers are only an approximation to the numeric truth.  In other words, they're not
commutative! For example, given two floats <em>a</em> and <em>b</em>, the result of <em>a+b</em> might be different
than that of <em>b+a</em>.</p>
</dd>
<dd>
<p>Each machine has its own accuracy, called the <em>machine epsilon</em>, which is the difference between 1
and the smallest exactly representable number greater than one. Most of the time only floats can be
compared that have been carried out to a certain number of decimal places.  In general this is the
case when two floats that result from a numeric operation are compared - but not two constants.
(Constants are accurate through to lexical conventions of the language. The Perl and C syntaxes for
numbers simply won't allow you to write down inaccurate numbers in code.)</p>
</dd>
<dd>
<p>See also recipes 2.2 and 2.3 in the Perl Cookbook.</p>
</dd>
<dd>
<p><strong>EXAMPLES</strong></p>
</dd>
<dd>
<pre>
    CALL                    RETURNS NUMBER
    ----                    --------------
    round('0.9957', 3)       0.996
    round(42, 2)             42
    round(0.12)              0.120000
    round(0.99, 2)           0.99
    round(0.991, 2)          0.99
    round(0.99, 1)           1.0
    round(1.096, 2)          1.10
    round(+.99950678)        0.999510
    round(-.00057260)       -0.000573
    round(-1.6804e-6)       -0.000002</pre>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="deep_compare__"><em>deep_compare()</em></a></h2>
<dl>
<dt><strong><a name="item_deep_compare"><em>deep_compare(A, B[, PRECISION, PRINT])</em></a></strong>

<dd>
<p>Compare and analyze two numbers, strings or references. Generates a log (stack of messages)
describing exactly all unequal data.  Hence, for some perl data <em>$a</em> and <em>$b</em> one can assert:</p>
</dd>
<dd>
<pre>
    croak &quot;$a differs from $b&quot; if deep_compare($a, $b);</pre>
</dd>
<dd>
<p>When PRINT is true traces progress on <em>stdout</em>.</p>
</dd>
<dd>
<p><strong>RESULT</strong></p>
</dd>
<dd>
<p>Returns an array of messages, each describing unequal data, or data that cannot be compared because
of type- or value-mismatching.  The array is empty when deep comparison of A and B found no unequal
numbers or strings, and only indifferent types.</p>
</dd>
<dd>
<p><strong>EXAMPLES</strong></p>
</dd>
<dd>
<p>The result is line-oriented, and for each mismatch it returns a single message:</p>
</dd>
<dd>
<pre>
    Data::Rlist::deep_compare(undef, 1)</pre>
</dd>
<dd>
<p>yields</p>
</dd>
<dd>
<pre>
    &lt;&lt;undef&gt;&gt; cmp &lt;&lt;1&gt;&gt;   stop! 1st undefined, 2nd defined (1)</pre>
</dd>
<dd>
<p>Some more complex example.  Deep-comparing two multi-level data structures A and B returned two
messages:</p>
</dd>
<dd>
<pre>
    'String literal' == REF(0x7f224)   stop! type-mismatch (scalar versus REF)
    'Greetings, earthlings!' == CODE(0x7f2fc)   stop! type-mismatch (scalar versus CODE)</pre>
</dd>
<dd>
<p>Somewhere in A a string <code>&quot;String literal&quot;</code> could not be compared, because the <em>corresponding</em>
element in B is a reference to a reference. Next it says that <code>&quot;Greetings, earthlings!&quot;</code> could not
be compared because the corresponding element in B is a code reference. (One could assert, however,
that the actual opacity here is that <em>they</em> speak ASCII.)</p>
</dd>
<dd>
<p>Actually, A and B are identical. B was written to disk (by <em><a href="#item_write">write()</a></em>)and then read back as A
(by <em><a href="#item_read">read()</a></em>).  So, why don't they compare anymore?  Because in B the refs <em>REF(0x7f224)</em> and
<em>CODE(0x7f2fc)</em> hide</p>
</dd>
<dd>
<pre>
    \&quot;String literal&quot;</pre>
</dd>
<dd>
<p>and</p>
</dd>
<dd>
<pre>
    sub { 'Greetings, earthlings!' }</pre>
</dd>
<dd>
<p>When writing B to disk <em>write()</em> has dissolved the scalar- and the code-reference into <code>&quot;String
literal&quot;</code> and <code>&quot;Greetings, earthlings!&quot;</code>. Of course, <em>deep_compare()</em> will not do that, so A does
not compare to B anymore.  Note that despite these two mismatches, <em>deep_compare()</em> had continued
the comparision for all other elements in A and B.  Hence the structures are identical in all other
elements.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="fork_and_wait____synthesize_pathname__"><em>fork_and_wait()</em>, <em>synthesize_pathname()</em></a></h2>
<dl>
<dt><strong><a name="item_fork_and_wait"><em>fork_and_wait(PROGRAM[, ARGS...])</em></a></strong>

<dd>
<p>Forks a process and waits for completion.  The function will extract the exit-code, test whether
the process died and prints status messages on <em>stderr</em>.  <em>fork_and_wait()</em> hence is a handy
wrapper around the built-in <em>system()</em> and <em>exec()</em> functions.  Returns an array of three values:</p>
</dd>
<dd>
<pre>
    ($exit_code, $failed, $coredump)</pre>
</dd>
<dd>
<p><em>$exit_code</em> is -1 when the program failed to execute (e.g. it wasn't found or the current user
has insufficient rights).  Otherwise <em>$exit_code</em> is between 0 and 255.  When the program died on
receipt of a signal (like <em>SIGINT</em> or <em>SIGQUIT</em>) then <em>$signal</em> stores it. When <em>$coredump</em> is
true the program died and a <em>core</em> file was written.  Note that some systems store <em>core</em>s
somewhere else than in the programs' working directory.</p>
</dd>
</li>
<dt><strong><a name="item_synthesize_pathname"><em>synthesize_pathname(TEXT...)</em></a></strong>

<dd>
<p>Concatenates and forms all TEXT strings into a symbolic name that can be used as a pathname.
<em>synthesize_pathname()</em> is a useful function to reuse a string, assembled from multiple strings,
coinstantaneously as hash key, database name, and file- or URL name.  Note, however, that few
characters are mapped to only <code>&quot;_&quot;</code> and <code>&quot;-&quot;</code>.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="imported_functions">IMPORTED FUNCTIONS</a></h1>
<p>
</p>
<h2><a name="explicit_imports">Explicit Imports</a></h2>
<p>Three tags are available that import function sets. These are utility functions usable also
separately from <em>Data::Rlist</em>.</p>
<dl>
<dt><strong><a name="item__3afloats"><em>:floats</em></a></strong>

<dd>
<p>Imports <em><a href="#item_equal">equal()</a></em>, <em><a href="#item_round">round()</a></em> and <em><a href="#item_is_numeric">is_numeric()</a></em>.</p>
</dd>
</li>
<dt><strong><a name="item__3astrings"><em>:strings</em></a></strong>

<dd>
<p>Imports <em><a href="#item_maybe_quote">maybe_quote()</a></em>, <em><a href="#item_quote">quote()</a></em>, <em><a href="#item_escape">escape()</a></em>, <em><a href="#item_unquote">unquote()</a></em>, <em><a href="#item_unescape">unescape()</a></em>,
<em><a href="#item_unhere">unhere()</a></em>, <em><a href="#item_is_random_text">is_random_text()</a></em>, <em><a href="#item_is_numeric">is_numeric()</a></em>, <em><a href="#item_is_name">is_name()</a></em>, <em><a href="#item_split_quoted">split_quoted()</a></em>, and
<em><a href="#item_parse_quoted">parse_quoted()</a></em>.</p>
</dd>
</li>
<dt><strong><a name="item__3aoptions"><em>:options</em></a></strong>

<dd>
<p>Imports <em><a href="#item_predefined_options">predefined_options()</a></em> and <em><a href="#item_complete_options">complete_options()</a></em>.</p>
</dd>
</li>
<dt><strong><a name="item__3aaux"><em>:aux</em></a></strong>

<dd>
<p>Imports <em><a href="#item_deep_compare">deep_compare()</a></em>, <em><a href="#item_fork_and_wait">fork_and_wait()</a></em> and <em><a href="#item_synthesize_pathname">synthesize_pathname()</a></em>.</p>
</dd>
</li>
</dl>
<p><strong>EXAMPLES</strong></p>
<pre>
    use Data::Rlist qw/:floats :strings/;</pre>
<p>
</p>
<h2><a name="automatic_imports">Automatic Imports</a></h2>
<p>These functions are implicitly imported into the callers symbol table by the package: <em>ReadCSV()</em>,
<em>ReadData()</em>, <em>WriteData()</em>, <em>PrintData()</em>, <em>OutlineData()</em>, <em>StringizeData()</em>,
<em>SqueezeData()</em>, <em>KeelhaulData()</em> and <em>CompareData()</em>.</p>
<p>You may say <em>require Data::Rlist</em> (instead of <em>use Data::Rlist</em>) to prohibit auto-import.  See
also <em>perlmod</em>.</p>
<p>
</p>
<h2><a name="importing_when_rlist_pm_is_installed_locally">Importing when <em>Rlist.pm</em> is installed locally</a></h2>
<p>Installing CPAN packages usually requires administrator privileges.  In case you don't have them,
another way is to the <em>Rlist.pm</em> file e.g. into <em>.</em> or <em>~/bin</em>:</p>
<pre>
    BEGIN {
        $0 =~ /[^\/]+$/;
        push @INC, $`||'.', &quot;$ENV{HOME}/bin&quot;;
        require Rlist;
        Data::Rlist-&gt;import();
        Data::Rlist-&gt;import(qw/:floats :strings/);
    }</pre>
<p>This code finds <em>Rlist.pm</em> also in <em>.</em> and <em>~/bin</em>.  It then calls the <em>Exporter</em> manually.</p>
<p>
</p>
<h2><a name="readcsv___and_readdata__"><em>ReadCSV()</em> and <em>ReadData()</em></a></h2>
<dl>
<dt><strong><a name="item_readcsv"><em>ReadCSV(INPUT[, DELIMITER, FILTER, FILTER-ARGS])</em></a></strong>

<dd>
<p>Calls <em><a href="#item_read_csv">read_csv()</a></em>.</p>
</dd>
</li>
<dt><strong><a name="item_readdata"><em>ReadData(INPUT[, FILTER, FILTER-ARGS])</em></a></strong>

<dd>
<p>Calls <em><a href="#item_read">read()</a></em>.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="writecsv___and_writedata__"><em>WriteCSV()</em> and <em>WriteData()</em></a></h2>
<dl>
<dt><strong><a name="item_writecsv"><em>WriteCSV(DATA[, OUTPUT, OPTIONS, COLUMNS])</em></a></strong>

<dd>
<p>Calls <em><a href="#item_write_csv">write_csv()</a></em>.</p>
</dd>
</li>
<dt><strong><a name="item_writedata"><em>WriteData(DATA[, OUTPUT, OPTIONS, HEADER])</em></a></strong>

<dd>
<p>Calls <em><a href="#item_write">write()</a></em>.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="outlinedata____stringizedata___and_squeezedata__"><em>OutlineData()</em>, <em>StringizeData()</em> and <em>SqueezeData()</em></a></h2>
<dl>
<dt><strong><a name="item_outlinedata"><em>OutlineData(DATA[, OPTIONS])</em></a></strong>

<dt><strong><a name="item_stringizedata"><em>StringizeData(DATA[, OPTIONS])</em></a></strong>

<dt><strong><a name="item_squeezedata"><em>SqueezeData(DATA[, OPTIONS])</em></a></strong>

<dd>
<p>Calls <em><a href="#item_make_string">make_string()</a></em>.</p>
</dd>
<dd>
<p><em>OutlineData()</em> applies the predefined <a href="#predefined_options"><code>&quot;outlined&quot;</code></a> <a href="#compile_options">options set</a>, while <em>StringizeData()</em> applies <a href="#predefined_options"><code>&quot;string&quot;</code></a> and <em>SqueezeData()</em>
<a href="#predefined_options"><code>&quot;squeezed&quot;</code></a>.  When specified, <a href="#compile_options">OPTIONS</a> are merged into
the predefined set.  For example,</p>
</dd>
<dd>
<pre>
    print &quot;\n\$thing: &quot;, OutlineData($thing, { precision =&gt; 12 });</pre>
</dd>
<dd>
<p><a href="#item_round">rounds</a> all numbers in <em>$thing</em> to 12 digits.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="keelhauldata___and_comparedata__"><em>KeelhaulData()</em> and <em>CompareData()</em></a></h2>
<dl>
<dt><strong><a name="item_keelhauldata"><em>KeelhaulData(DATA[, OPTIONS])</em></a></strong>

<dd>
<p>Calls <em><a href="#item_keelhaul">keelhaul()</a></em>.  For example,</p>
</dd>
<dd>
<pre>
    use Data::Rlist;
        .
        .
    my($copy, $as_text) = KeelhaulData($thing);</pre>
</dd>
</li>
<dt><strong><a name="item_comparedata"><em>CompareData(A, B[, PRECISION, PRINT_TO_STDOUT])</em></a></strong>

<dd>
<p>Calls <em><a href="#item_deep_compare">deep_compare()</a></em>.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="history___notes">HISTORY / NOTES</a></h1>
<p>The <em>Random Lists</em> (Rlist) syntax is inspired by NeXTSTEP's <em>Property Lists</em>.  Rlist is simpler,
more readable and more portable.  The Perl, C and C++ implementations are fast, table and free.
Markus Felten, with whom I worked a few month in a project at Deutsche Bank, Frankfurt in summer
1998, arrested my attention on Property lists.  He had implemented a Perl variant of it
(<em><a href="#http___search_cpan_org_searchdist_datapropertylist"><a href="http://search.cpan.org/search?dist=Data-PropertyList">http://search.cpan.org/search?dist=Data-PropertyList</a></a></em>).</p>
<p>The term ``Random'' underlines the fact that the language</p>
<ul>
<li>
<p>has only four primitive data types;</p>
</li>
<li>
<p>the basic building block is a list (sequential or associative), and this list can be combined <em>at
random</em> with other lists.</p>
</li>
</ul>
<p>Hence the term ``Random'' does not mean <em>aimless</em> or <em>accidental</em>.  <em>Random Lists</em> are <em>arbitrary
lists</em>.  Application data can be made portable (due to 7-bit-ASCII) and persistent by dealing
arbitrarily with lists of numbers and strings.  Like with CSV the lexical overhead Rlist imposes is
minimal: files are merely data.  Also, files are viewable/editable by text editors.  Users then
shall not be dazzled by language gizmo's.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>
</p>
<h2><a name="data__dumper"><em>Data::Dumper</em></a></h2>
<p>In contrast to the <em>Data::Dumper</em>, <em>Data::Rlist</em> scalars will be properly <em>typed</em> as number or
string.  <em>Data::Dumper</em> writes numbers always as quoted strings, for example</p>
<pre>
    $VAR1 = {
                'configuration' =&gt; {
                                    'verbose' =&gt; 'Y',
                                    'importance_sampling_loss_quantile' =&gt; '0.04',
                                    'distribution_loss_unit' =&gt; '100',
                                    'default_only' =&gt; 'Y',
                                    'num_threads' =&gt; '5',
                                            .
                                            .
                                   }
            };</pre>
<p>where <em>Data::Rlist</em> writes</p>
<pre>
    {
        configuration = {
            verbose = Y;
            importance_sampling_loss_quantile = 0.04;
            distribution_loss_unit = 100;
            default_only = Y;
            num_threads = 5;
                .
                .
        }
    }</pre>
<p>As one can see <em>Data::Dumper</em> writes the data right in Perl syntax, which means the dumped text
can be simply <em>eval</em>'d. Rlists are not Perl-syntax and need to be parsed carefully.  But Rlist
text is portable (7-bit-ASCII with non-printables escaped) and implementations exist for other
programming languages, namely C++ which uses a fast flex/bison-parser.</p>
<p>While reading <em>Data::Dumper</em>-generated files back is generally faster than <em><a href="#item_read">read()</a></em>.  For
example, with <em>$Data::Dumper::Useqq</em> enabled, it was observed that <em>Data::Dumper</em> renders output
three to four times slower than <em><a href="#item_compile">compile()</a></em></p>
<p>Consider also that <em>Data::Rlist</em> tests for any scalar whether it is numeric or not (see
<em><a href="#item_is_random_text">is_random_text()</a></em>), where <em>Data::Dumper</em> simply quotes any number and string.  So
<em>Data::Rlist</em> is able to implicitly round floats to a certain precision, making them finally
comparable (see <em><a href="#item_round">round()</a></em> for more information).</p>
<p><em>Data::Rlist</em> generates much smaller files: with the default <em>$Data::Dumper::Indent</em> of 2 Rlist
output is just 15-20% of the size the <em>Data::Dumper</em> package prints (for the same data).  The
simple reason: <em>Data::Dumper</em> recklessly uses many whitespaces (blanks) instead of horizontal
tabulators; this unnecessarily blows up file sizes.</p>
<p>
</p>
<hr />
<h1><a name="dependencies">DEPENDENCIES</a></h1>
<p><em>Data::Rlist</em> depends only on few other packages:</p>
<pre>
    Exporter
    Carp
    strict
    integer
    Sys::Hostname
    Scalar::Util        # deep_compare() only
    Text::Wrap          # unhere() only
    Text::ParseWords    # split_quoted(), parse_quoted() only</pre>
<p><em>Data::Rlist</em> is free of <em>$&amp;</em>, <em>$`</em> or <em>$'</em>. Reason: once Perl sees that you need one of these
meta-variables anywhere in the program, it has to provide them for every pattern match.  This may
substantially slow your program (see also <em>perlre</em>).</p>
<p>
</p>
<hr />
<h1><a name="bugs_and_deficiencies">BUGS AND DEFICIENCIES</a></h1>
<p>There are no known bugs, this package is stable.</p>
<p>Deficiencies of this version:</p>
<ul>
<li>
<p><a href="#embedded_perl_code">nanoscripts</a> not yet implemented.</p>
</li>
<li>
<p>The <code>&quot;deparse&quot;</code> functionality for the <code>&quot;code_refs&quot;</code> <a href="#compile_options">compile option</a> has not
yet been implemented.</p>
</li>
<li>
<p>The <code>&quot;threads&quot;</code> <a href="#compile_options">compile option</a> has not yet been implemented.</p>
</li>
<li>
<p>IEEE 754 notations of Infinite and NaN not yet implemented.</p>
</li>
<li>
<p>To increase compilation speed, a string <em>$s</em> is only <em><a href="#item_quote">quote()</a></em>d when
<em>$s!~$Data::Rlist::g_re_value</em>. (Note that this regex is applied also by <em><a href="#item_is_random_text">is_random_text()</a></em>.)
The regex checks wether <em>$s</em> begins with <code>&quot;</code>, or defines a symbolic name or a number.  But when
the 1st character of <em>$s</em> is <code>&quot;</code>, no further test are made whether characters in the actually
require escaping.  It is then believed that the string adheres to 7-bit-ASCII.  If this isn't the
case it might not be read back correctly.  See also <em><a href="#item_is_name">is_name()</a></em>, <em><a href="#item_is_integer">is_integer()</a></em> and
<em><a href="#item_is_numeric">is_numeric()</a></em>.</p>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Andreas Spindler, <em><a href="mailto:rlist@visualco.de">rlist@visualco.de</a></em></p>
<p>
</p>
<hr />
<h1><a name="copyright_and_license">COPYRIGHT AND LICENSE</a></h1>
<p>Copyright 1998-2007 Andreas Spindler</p>
<p>Maintained at CPAN and <a href="#http___www_visualco_de"><a href="http://www.visualco.de">http://www.visualco.de</a></a></p>
<p>See <a href="http://search.cpan.org/~aspindler">http://search.cpan.org/~aspindler</a>.</p>
<p>This library is free software; you can redistribute it and/or modify it under the same terms as
Perl itself, either Perl version 5.8.8 or, at your option, any later version of Perl 5 you may have
available.</p>
<p>Thank you for your attention.</p>

</body>

</html>
